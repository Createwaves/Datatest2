<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lysterfield Sailing Club Results</title>
    <style>
        /* CSS Styles (Existing styles merged with additions for boat list) */
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f8ff;
        }
        h1, h2, h3 {
            color: #003366;
        }
        h4 { /* Style for Race N headers */
             color: #003366;
             margin-top: 15px;
             margin-bottom: 5px;
             border-bottom: 1px solid #ccc;
             padding-bottom: 3px;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input, select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box; /* Important for width: 100% */
        }
        /* Allow inputs/selects in specific containers to be auto width */
        .filter-group select, .filter-group input,
        .series-select select, .series-select input,
        .short-course-race-entry select, .short-course-race-entry input { /* Added short course */
            width: auto;
            padding: 4px 6px; /* Smaller padding for table inputs */
            font-size: 13px; /* Slightly smaller font */
        }
         /* Make time inputs wider in short course table */
        .short-course-race-entry input[type="text"] {
             min-width: 80px;
         }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            gap: 5px; /* Added for spacing between checkbox and label */
        }
        .checkbox-group input[type="checkbox"] { /* Target only checkboxes */
            width: auto;
            /* margin-right: 8px; Replaced by gap */
        }
        .checkbox-group label {
            display: inline;
            margin-bottom: 0;
            font-weight: normal; /* Normal weight for checkbox labels */
        }
        button {
            background-color: #003366;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 5px; /* Add bottom margin for wrapping */
        }
        button:hover {
            background-color: #004080;
        }
        .btn-secondary { background-color: #4682B4; }
        .btn-secondary:hover { background-color: #5891c4; }
        .btn-warning { background-color: #ff9800; }
        .btn-warning:hover { background-color: #e68a00; }
        .btn-danger { background-color: #dc3545; }
        .btn-danger:hover { background-color: #c82333; }
        .btn-edit { background-color: #28a745; }
        .btn-edit:hover { background-color: #218838; }
        .btn-save { background-color: #17a2b8; }
        .btn-save:hover { background-color: #138496; }
        .btn-create-race { background-color: #ff9800; } /* Orange for Create Race */
        .btn-create-race:hover { background-color: #e68a00; }

        /* Results Styling */
        .results-table, #boat-list-table, #entries-table, .short-course-race-table { /* Apply common table styles */
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 14px;
        }
        .results-table th, #boat-list-table th, #entries-table th, .short-course-race-table th {
            background-color: #003366;
            color: white;
            text-align: left;
            padding: 6px 8px;
            font-weight: bold;
        }
        .results-table td, #boat-list-table td, #entries-table td, .short-course-race-table td {
            padding: 4px 8px;
            border: 1px solid #ddd; /* Add border to all table cells */
            text-align: left;
            vertical-align: middle; /* Align content vertically */
        }
        .results-table tr:nth-child(even), #boat-list-table tr:nth-child(even),
        #entries-table tr:nth-child(even), .short-course-race-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .results-table tr:hover, #boat-list-table tr:hover,
        #entries-table tr:hover, .short-course-race-table tr:hover {
            background-color: #e8f4ff;
        }

        .race-info-panel {
            background-color: #f0f8ff;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
        }
        .race-info-panel h3 { margin-top: 0; margin-bottom: 5px; }
        .race-info-panel p { margin: 5px 0; }

        /* Removed colour rules */

        .discarded { text-decoration: line-through; color: #888; font-style: italic; }
        .legend { font-size: 12px; margin-top: 15px; border-top: 1px solid #ddd; padding-top: 10px; }
        .legend span { margin-right: 5px; display: inline-block; }
        .legend strong { margin-right: 10px; }
        .legend .discarded-example { text-decoration: line-through; font-style: italic; color: #888; }

        .actions { display: flex; gap: 5px; flex-wrap: wrap; align-items: center; } /* Added align-items */
        .actions button { margin-right: 0; margin-bottom: 0; padding: 3px 6px; font-size: 10px; } /* Removed bottom margin */

        .entry-form, #boat-list-form /* Apply style to both forms */ {
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .status-option { display: flex; align-items: center; margin: 10px 0; }
        /* Make radio buttons smaller and aligned */
        .status-option input[type="radio"] {
             width: auto;
             margin-right: 8px;
             padding: 0; /* Remove default padding */
             vertical-align: middle; /* Align with label text */
        }
        .status-option label {
            display: inline; /* Allow label next to radio */
            margin-bottom: 0; /* Remove block spacing */
            font-weight: normal; /* Normal weight */
             vertical-align: middle; /* Align with radio button */
        }
        .entry-buttons { display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap; }
        .result-highlight { background-color: #fffce8 !important; }
        .tab-buttons { margin-bottom: 15px; display: flex; flex-wrap: wrap; gap: 5px; }
        .tab-buttons button { margin-right: 0; }
        .tab-content { display: none; }
        .active-tab { display: block; }
        .active-button { background-color: #0056b3; }
        .race-card { border: 1px solid #ddd; border-radius: 4px; padding: 15px; margin-bottom: 15px; background-color: #f9f9f9; }
        .race-card h3 { margin-top: 0; }
        .race-info { display: flex; justify-content: space-between; margin-bottom: 10px; flex-wrap: wrap; }
        .race-actions { margin-top: 10px; }
        .series-header { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; }

        /* --- START: ENHANCED .series-select STYLES --- */
        .series-select {
            display: flex;
            flex-wrap: wrap; /* Allow items to wrap to the next line */
            align-items: center; /* Align items nicely if they wrap */
            gap: 10px; /* Spacing between label/select pairs or individual items */
            margin-bottom: 20px;
        }
        .series-select label {
            display: inline; /* Override general label: block */
            margin-bottom: 0; /* Override general label margin */
            margin-right: 5px; /* Space between label and its immediate select/input */
            font-weight: bold; /* Keep it bold */
        }
        #race-selector-wrapper { /* Specific wrapper for race number select in Race Entry tab */
            display: inline-flex; /* Treat as a single unit for wrapping, keeps its label and select together */
            align-items: center;
            gap: 5px; /* Space between its internal label and select */
        }
        /* --- END: ENHANCED .series-select STYLES --- */

        .series-date { margin-top: 10px; }
        .edit-result-form { margin-top: 20px; padding: 15px; border: 1px solid #ddd; border-radius: 4px; background-color: #f8f9fa; }
        .edit-mode-warning { background-color: #fff3cd; padding: 10px; border-radius: 4px; margin-bottom: 15px; border: 1px solid #ffeeba; color: #856404; }
        .race-view-container { margin-top: 15px; }
        .race-selector { display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .race-selector button { padding: 5px 10px; font-size: 12px; }
        .race-button { background-color: #f2f2f2; color: #333; border: 1px solid #ddd; }
        .race-button.active { background-color: #003366; color: white; }
        .race-button.has-results { border: 2px solid #28a745; }
        #results-table th:last-child, #results-table td:last-child { width: auto; min-width: 50px; text-align: center; } /* Actions col */
        #boat-list-table th:last-child, #boat-list-table td:last-child { width: auto; min-width: 100px; text-align: center; } /* Actions col for boat list */
        #entries-table th:last-child, #entries-table td:last-child { width: auto; min-width: 100px; text-align: center; } /* Actions col for entries */
        .short-course-race-table th:nth-child(5), .short-course-race-table td:nth-child(5) { width: 120px; } /* Status Col Width */
        .short-course-race-table th:nth-child(6), .short-course-race-table td:nth-child(6) { width: 100px; } /* Time Col Width */
        .short-course-race-table th:last-child, .short-course-race-table td:last-child { width: auto; min-width: 60px; text-align: center; } /* Actions Col Width */

        .series-results-table td, .series-results-table th { white-space: nowrap; }
        .series-results-table .nr-cell { color: #999; font-style: italic; text-align: center; }
        .action-buttons { display: flex; flex-wrap: wrap; gap: 10px; margin: 15px 0; }
        .action-buttons button { margin-right: 0; }
        /* Specific styling for saved boat dropdown */
        #saved-boat-selector { margin-bottom: 20px; /* Optional: Adjust spacing */ }
        #saved-boat-selector label { margin-bottom: 8px; }
        .hidden { display: none !important; } /* Utility class */

        /* Container for short course created races */
        #short-course-races-container {
            margin-top: 25px;
            border-top: 2px solid #003366;
            padding-top: 15px;
        }
        .short-course-race-section {
             border: 1px solid #ccc;
             border-radius: 5px;
             padding: 10px 15px;
             margin-bottom: 15px;
             background-color: #f9f9f9;
        }
        .short-course-race-section h4 { margin-top: 0; } /* Reset top margin for section header */

        /* Loading overlay */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5em;
        }
    </style>
</head>
<body>
    <div id="loading-overlay" class="hidden">Saving to Cloud...</div> <!-- Loading Indicator -->
    <div class="container">
        <h1>Lysterfield Results App</h1>

        <div class="tab-buttons">
            <button id="btn-series" class="active-button">Series Management</button>
            <button id="btn-boat-list">Boat List</button>
            <button id="btn-race">Race Entry</button>
            <button id="btn-results">Race Results</button>
            <button id="btn-series-results">Series Results</button>
            <button id="btn-race-view">Race Viewer</button>
        </div>

        <!-- Series Management Tab -->
        <div id="series-tab" class="tab-content active-tab">
            <div class="series-header"><h2>Series Management</h2><button id="create-series-btn">Create New Series</button></div>
            <!-- Series Create/Edit Form -->
            <div id="create-series-form" class="entry-form hidden"> <!-- Start hidden -->
                <h3>Create/Edit Series</h3>
                <div class="form-group">
                    <label for="series-name">Series Name:</label>
                    <input type="text" id="series-name" placeholder="e.g., Summer Series 2024">
                </div>
                <!-- ========== START: SHORT COURSE CHECKBOX ========== -->
                <div class="checkbox-group">
                    <input type="checkbox" id="series-short-course">
                    <label for="series-short-course">This is a Short Course Series (Races created dynamically)</label>
                </div>
                <!-- ========== END: SHORT COURSE CHECKBOX ========== -->
                <div id="standard-series-options"> <!-- Wrapper for options hidden in short course -->
                    <div class="form-group">
                        <label for="number-of-races">Number of Races Planned:</label>
                        <input type="number" id="number-of-races" min="1" max="50" value="8">
                    </div>
                    <div class="form-group">
                        <label for="races-per-discard">Discard 1 race after how many completed races? (Enter 0 for no discards)</label>
                        <input type="number" id="races-per-discard" min="0" max="20" value="4">
                        <small>Example: If set to 5, 1 discard applies after race 5, 2 discards after race 10, etc.</small>
                    </div>
                </div>
                 <!-- DNC rule applies to both types -->
                <div class="form-group">
                    <label>DNC Points Calculation:</label>
                    <div class="status-option">
                        <input type="radio" id="dnc-rule-race" name="dnc-scoring-rule" value="raceEntries" checked>
                        <label for="dnc-rule-race">Entries in specific Race + 1</label>
                    </div>
                    <div class="status-option">
                        <input type="radio" id="dnc-rule-series" name="dnc-scoring-rule" value="seriesCompetitors">
                        <label for="dnc-rule-series">Total unique competitors in Series + 1</label>
                    </div>
                </div>

                <input type="hidden" id="edit-series-id">
                <div class="entry-buttons">
                    <button id="save-series-btn">Save Series</button>
                    <button id="cancel-series-btn" class="btn-secondary">Cancel</button>
                </div>
            </div>
            <!-- Series List Display -->
            <div id="series-list">
                <!-- Series cards will be generated here -->
            </div>

            <div class="action-buttons" style="margin-top: 30px; border-top: 1px solid #ccc; padding-top: 20px;">
                <h3>Data Management (Local JSON Files)</h3>
                <button id="export-all-data-btn" class="btn-secondary">Export All Data (JSON)</button>
                <button id="import-data-btn" class="btn-warning">Import Data (JSON - Replaces Current)</button>
                <input type="file" id="import-file-input" accept=".json" style="display: none;">
                <p style="font-size: 12px; color: #666; margin-top: 5px;">
                    These buttons manage local JSON file backups. Data is primarily saved to Google Sheets.
                    Import will <strong>replace</strong> all current data (in app & then saved to Sheets) with the data from the selected file.
                </p>
            </div>

        </div> <!-- End of series-tab -->


        <!-- Boat List Tab -->
        <div id="boat-list-tab" class="tab-content">
             <div class="series-header">
                <h2>Manage Boat List</h2>
                <button id="show-add-boat-form-btn">Add New Boat</button>
            </div>
             <div id="boat-list-form" class="entry-form hidden"> <!-- Start hidden -->
                 <h3 id="boat-form-title">Add New Boat</h3>
                 <div class="form-group">
                     <label for="boat-sail-number">Sail Number: If a club boat, replace sail number with boat class and name of sailor - Example: Club Pacer John R</label>
                     <input type="text" id="boat-sail-number" placeholder="e.g., AUS123 (Must be unique)">
                 </div>
                  <div class="form-group">
                     <label for="boat-class-list">Default Boat Class:</label>
                     <select id="boat-class-list">
                         <option value="">Select boat class</option>
                         <!-- Populated from yardstick data -->
                     </select>
                 </div>
                 <div class="checkbox-group">
                     <input type="checkbox" id="boat-manual-class-check">
                     <label for="boat-manual-class-check">Enter boat class manually</label>
                 </div>
                 <div id="boat-manual-class-input" class="form-group hidden"> <!-- Use class -->
                     <label for="boat-manual-boat-class">Custom Boat Class:</label>
                     <input type="text" id="boat-manual-boat-class" placeholder="Enter custom boat class">
                 </div>
                  <div class="form-group">
                     <label for="boat-skipper">Default Skipper Name:</label>
                     <input type="text" id="boat-skipper" placeholder="Full name">
                 </div>
                  <div class="form-group">
                     <label for="boat-yardstick">Default Yardstick:</label>
                     <input type="number" id="boat-yardstick" step="0.1" placeholder="Auto-filled or enter manually">
                 </div>
                  <div class="checkbox-group">
                     <input type="checkbox" id="boat-manual-yardstick-check">
                     <label for="boat-manual-yardstick-check">Enter yardstick manually</label>
                 </div>
                 <input type="hidden" id="editing-boat-id" value="">
                 <div class="entry-buttons">
                     <button id="save-boat-list-btn">Save Boat</button>
                     <button id="cancel-boat-list-btn" class="btn-secondary">Cancel</button>
                 </div>
             </div>
             <h3>Saved Boats</h3>
              <div style="overflow-x: auto;">
                 <table id="boat-list-table">
                     <thead>
                         <tr>
                             <th>Sail #</th>
                             <th>Boat Class</th>
                             <th>Skipper</th>
                             <th>Yardstick</th>
                             <th>Actions</th>
                         </tr>
                     </thead>
                     <tbody id="boat-list-body"></tbody>
                 </table>
             </div>

              <div class="action-buttons" style="margin-top: 30px; border-top: 1px solid #ccc; padding-top: 20px;">
                 <h3>Boat List Data Management (Local JSON Files)</h3>
                 <button id="export-boat-list-btn" class="btn-secondary">Export Boat List Only (JSON)</button>
                 <button id="import-boat-list-btn" class="btn-warning">Import Boat List (JSON - Replaces Current)</button>
                 <input type="file" id="import-boat-list-file-input" accept=".json" style="display: none;">
                 <p style="font-size: 12px; color: #666; margin-top: 5px;">
                    Export creates a JSON backup of the current saved boat list.
                    Import will <strong>replace</strong> the current boat list (in app & then saved to Sheets).
                 </p>
             </div>
        </div> <!-- End of boat-list-tab -->

        <!-- Race Entry Tab (MODIFIED for Short Course) -->
        <div id="race-tab" class="tab-content">
            <h2>Race Entry</h2>

           <div class="series-select">
                <label for="select-series">Select Series:</label>
                <select id="select-series"></select>
                 <!-- ========== MODIFIED: Race selector wrapper (hidden for short course) ========== -->
                <span id="race-selector-wrapper">
                    <label for="select-race">Select Race Number:</label> <!-- REMOVED INLINE STYLE -->
                    <select id="select-race"></select>
                </span>
                 <!-- ========== END MODIFICATION ========== -->
            </div>

            <div id="edit-mode-warning" class="edit-mode-warning hidden"></div>

            <!-- Entry Form -->
            <div class="entry-form">
                <h3 id="entry-form-title">Add/Edit Boat Entry</h3>

                <div id="saved-boat-selector" class="form-group">
                    <label for="select-saved-boat">Select Saved Boat (Optional):</label>
                    <select id="select-saved-boat">
                        <option value="">-- Select Saved Boat --</option>
                        <!-- Populated from boatList -->
                    </select>
                    <small>Selecting a boat will pre-fill the details below. You can still modify them.</small>
                </div>

                <div class="form-group"><label for="sail-number">Sail Number:</label><input type="text" id="sail-number" placeholder="e.g. AUS123"></div>
                <div class="form-group"><label for="boat-class">Boat Class:</label><select id="boat-class"><option value="">Select boat class</option></select></div>
                <div class="checkbox-group"><input type="checkbox" id="manual-class-check"><label for="manual-class-check">Enter boat class manually</label></div>
                <div id="manual-class-input" class="form-group hidden"><label for="manual-boat-class">Custom Boat Class:</label><input type="text" id="manual-boat-class"></div>
                <div class="form-group"><label for="skipper">Skipper Name:</label><input type="text" id="skipper" placeholder="Full name"></div>
                <div class="form-group"><label for="yardstick">Yardstick (PN):</label><input type="number" id="yardstick" step="0.1" placeholder="Auto-filled or enter manually"></div>
                <div class="checkbox-group"><input type="checkbox" id="manual-yardstick-check"><label for="manual-yardstick-check">Enter yardstick manually</label></div>

                <!-- ========== MODIFIED: Status and Time inputs wrapper (hidden for short course entry) ========== -->
                <div id="standard-entry-fields">
                    <div class="form-group"><label>Race Status:</label><!-- Status Radio Buttons -->
                        <div class="status-option"><input type="radio" id="status-finished" name="race-status" value="finished" checked><label for="status-finished">Finished</label></div>
                        <div class="status-option"><input type="radio" id="status-dnf" name="race-status" value="DNF"><label for="status-dnf">DNF</label></div>
                        <div class="status-option"><input type="radio" id="status-dns" name="race-status" value="DNS"><label for="status-dns">DNS</label></div>
                        <div class="status-option"><input type="radio" id="status-ocs" name="race-status" value="OCS"><label for="status-ocs">OCS</label></div>
                        <div class="status-option"><input type="radio" id="status-dsq" name="race-status" value="DSQ"><label for="status-dsq">DSQ</label></div>
                        <div class="status-option"><input type="radio" id="status-ood" name="race-status" value="OOD"><label for="status-ood">OOD</label></div>
                    </div>
                    <div id="time-inputs" class="form-group"><label for="elapsed-time">Elapsed Time (hh:mm:ss):</label><input type="text" id="elapsed-time" placeholder="e.g. 01:30:45"></div>
                </div>
                <!-- ========== END MODIFICATION ========== -->

                <div class="entry-buttons">
                    <button id="add-boat">Add Boat</button> <!-- Text changes dynamically -->
                    <button id="update-boat" class="btn-edit hidden">Update Boat</button>
                    <button id="cancel-update" class="btn-secondary hidden">Cancel Update</button>
                    <button id="clear-form" class="btn-secondary">Clear Form</button>
                </div>
                <input type="hidden" id="editing-entry-index" value="-1">
                 <!-- Hidden input to track editing within a short course race -->
                <input type="hidden" id="editing-short-course-race-index" value="-1">
            </div>

             <!-- ========== STANDARD ENTRIES DISPLAY (Hidden for Short Course) ========== -->
            <div id="standard-entries-display">
                <h3 id="current-entries-heading">Current Entries for Selected Race</h3>
                <div style="overflow-x: auto;">
                    <table id="entries-table">
                        <thead><tr><th>Sail #</th><th>Boat Class</th><th>Skipper</th><th>Yardstick</th><th>Status</th><th>Elapsed Time</th><th>Actions</th></tr></thead>
                        <tbody id="entries-body"></tbody>
                    </table>
                </div>
            </div>
            <!-- ========== END STANDARD ========== -->

             <!-- ========== SHORT COURSE STAGING AREA (Shown for Short Course) ========== -->
            <div id="short-course-staging-display" class="hidden">
                <h3 id="short-course-pool-heading">Race Entries (Add/Remove Boats Here)</h3>
                 <div style="overflow-x: auto;">
                     <table id="short-course-pool-table" class="results-table"> <!-- Use results-table style -->
                         <thead><tr><th>Sail #</th><th>Boat Class</th><th>Skipper</th><th>Yardstick</th><th>Actions</th></tr></thead>
                         <tbody id="short-course-pool-body"></tbody>
                     </table>
                 </div>
                 <div class="action-buttons">
                     <button id="create-short-course-race-btn" class="btn-create-race">Create Race 1</button>
                 </div>
            </div>
            <!-- ========== END SHORT COURSE STAGING ========== -->

             <!-- ========== SHORT COURSE CREATED RACES CONTAINER ========== -->
             <div id="short-course-races-container" class="hidden">
                 <h3>Created Races (This Session)</h3>
                 <!-- Race N sections will be appended here by JS -->
             </div>
             <!-- ========== END SHORT COURSE CREATED RACES ========== -->


            <div style="margin-top: 20px;" class="action-buttons">
                <button id="calculate-results">Calculate Race Results & View</button>
                <button id="clear-all" class="btn-warning">Clear Current List/Pool</button>
                <!-- ========== ADDED: Clear Short Course Races Button ========== -->
                <button id="clear-short-course-session-btn" class="btn-danger hidden">Clear Created Races</button>
                <!-- ========== END ADDITION ========== -->
            </div>
        </div>


        <!-- Race Results Tab -->
        <div id="results-tab" class="tab-content">
             <h2>Race Results</h2>
             <div class="series-select">
                <label for="results-series-select">Series:</label>
                <select id="results-series-select"></select>
                <label for="results-race-select">Race:</label>
                <select id="results-race-select"></select>
            </div>
             <div id="result-race-info"></div>
             <div class="action-buttons">
                <button id="save-results-tab-btn" class="btn-save">Save These Results to Series</button>
                <button id="edit-race-entries" class="btn-edit">Edit Race Entries</button>
                <button id="edit-results-directly" class="btn-warning">Direct Edit</button>
            </div>
             <div id="direct-edit-warning" class="edit-mode-warning hidden"></div>
             <div style="overflow-x: auto;">
                <table id="results-table" class="results-table">
                    <thead><tr><th>Pos</th><th>Sail No</th><th>Boat Type</th><th>Helm</th><th>YS</th><th>Finish</th><th>Elapsed</th><th>Corrected</th><th>Points</th><th>Actions</th></tr></thead>
                    <tbody id="results-body"></tbody>
                </table>
            </div>
             <div id="edit-result-form" class="edit-result-form hidden"><h3>Edit Result (Directly)</h3><p>Editing: <strong id="edit-result-label"></strong></p><!-- Direct Edit Fields -->
                <div class="form-group"><label for="edit-status-direct">Status:</label><select id="edit-status-direct"></select></div>
                <div id="edit-time-inputs-direct" class="form-group"><label for="edit-elapsed-time-direct">Elapsed Time:</label><input type="text" id="edit-elapsed-time-direct" placeholder="hh:mm:ss"></div>
                <div class="form-group"><label for="edit-position-direct">Position:</label><input type="text" id="edit-position-direct" placeholder="e.g., 3 or DNF"></div>
                <div class="form-group"><label for="edit-points-direct">Points:</label><input type="number" step="0.1" id="edit-points-direct"></div>
                <input type="hidden" id="edit-result-index">
                <div class="entry-buttons"><button id="save-edit-result">Update Displayed Result</button><button id="cancel-edit-result" class="btn-secondary">Cancel</button></div>
             </div>
        </div>

        <!-- Series Results Tab -->
        <div id="series-results-tab" class="tab-content">
             <h2>Series Results</h2>
             <div class="series-select">
                <label for="view-series-select">Select Series:</label>
                <select id="view-series-select"></select>
            </div>
             <div id="series-summary"></div>
             <div style="overflow-x: auto;">
                <table id="series-results-table" class="results-table series-results-table">
                    <thead id="series-results-header"></thead>
                    <tbody id="series-results-body"></tbody>
                </table>
            </div>
             <div class="legend"><strong>Legend:</strong><!-- Populated by JS --></div>
        </div>

        <!-- Race Viewer Tab -->
        <div id="race-view-tab" class="tab-content">
             <h2>Race Viewer</h2>
             <div class="series-select">
                <label for="view-all-series-select">Select Series:</label>
                <select id="view-all-series-select"></select>
            </div>
             <div id="race-summary-view"></div>
             <div class="race-selector"></div>
             <div class="race-view-container">
                <div id="individual-race-info"></div>
                <div style="overflow-x: auto;">
                    <table id="individual-race-results" class="results-table">
                        <thead><!-- Set by JS --></thead>
                        <tbody id="individual-race-body"></tbody>
                    </table>
                </div>
            </div>
        </div>

    </div>

    <script>
        const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbyTHgUnij7DiwsbKiA7jjNHjNohNfxXW9mtJpkt4XlDrlAXpGoaT4JLeEfSkwcosJHXcw/exec';

        // Yardstick data (still needed for dropdowns)
        const yardstickData = [
            { boatClass: "125", yardstick: 123 }, { boatClass: "145", yardstick: 113 }, { boatClass: "29er", yardstick: 95 }, { boatClass: "420", yardstick: 112 }, { boatClass: "470", yardstick: 101 },
            { boatClass: "505", yardstick: 93 }, { boatClass: "B14", yardstick: 94 }, { boatClass: "Byte", yardstick: 125.4 }, { boatClass: "Byte CII", yardstick: 120.4 }, { boatClass: "Cherub", yardstick: 100 },
            { boatClass: "Contender", yardstick: 106.5 }, { boatClass: "Corsair", yardstick: 119.5 }, { boatClass: "E Class (Lazy E)", yardstick: 113 }, { boatClass: "Europe Dinghy", yardstick: 120 },
            { boatClass: "Fireball", yardstick: 101 }, { boatClass: "Finn", yardstick: 110 }, { boatClass: "Flying Ant", yardstick: 135 }, { boatClass: "Flying 11", yardstick: 117 }, { boatClass: "Heron", yardstick: 134 },
            { boatClass: "Impulse", yardstick: 118.5 }, { boatClass: "Impulse 6.6", yardstick: 124.5 }, { boatClass: "Javelin", yardstick: 97.5 }, { boatClass: "Jubilee", yardstick: 130 }, { boatClass: "Laser", yardstick: 114 },
            { boatClass: "Laser Radial", yardstick: 118.5 }, { boatClass: "Laser 4.7", yardstick: 127 }, { boatClass: "Mirror", yardstick: 143 }, { boatClass: "Moth Skiff", yardstick: 60 }, { boatClass: "Moth Scow", yardstick: 115 },
            { boatClass: "NS14", yardstick: 108 }, { boatClass: "OK Dinghy", yardstick: 115.5 }, { boatClass: "Open Bic", yardstick: 153.3 }, { boatClass: "Optimist", yardstick: 170 }, { boatClass: "Pacer", yardstick: 127.5 },
            { boatClass: "Pacer Non Spinnaker", yardstick: 130.4}, { boatClass: "RS 100 8.4", yardstick: 106 }, { boatClass: "RS 100 10.2", yardstick: 103 }, { boatClass: "RS 200", yardstick: 108.5 }, { boatClass: "RS 300", yardstick: 103.4 },
            { boatClass: "RS 400", yardstick: 96.6 }, { boatClass: "RS 500", yardstick: 102.7 }, { boatClass: "RS 600", yardstick: 87.2 }, { boatClass: "RS 700", yardstick: 83.8 }, { boatClass: "RS 800", yardstick: 86.3 },
            { boatClass: "RS Aero 5", yardstick: 116.8 }, { boatClass: "RS Aero 6", yardstick: 114.6 }, { boatClass: "RS Aero 7", yardstick: 112.5 }, { boatClass: "RS Aero 9", yardstick: 108 }, { boatClass: "RS Feva XL", yardstick: 130 },
            { boatClass: "RS Tera Pro", yardstick: 143.2 }, { boatClass: "RS Tera Sport", yardstick: 153.9 }, { boatClass: "RS Vareo", yardstick: 113.1 }, { boatClass: "RS Vision", yardstick: 123.7 }, { boatClass: "Sabre", yardstick: 127 },
            { boatClass: "Sailfish", yardstick: 132 }, { boatClass: "Sparrow", yardstick: 145 }, { boatClass: "Solo", yardstick: 123.5 }, { boatClass: "Sabot", yardstick: 160.5 }, { boatClass: "Sharpie", yardstick: 95 },
            { boatClass: "Spiral", yardstick: 124 }, { boatClass: "Tasar", yardstick: 108 },
        ];

        // --- App State ---
        let entries = []; // Holds entries for standard races OR the "pool" for short courses
        let results = []; // Holds calculated results for display on Results tab
        let series = []; // Holds all series data
        let boatList = []; // Holds saved boat data
        let shortCourseSessionRaces = []; // Holds {raceNumber, entries:[{..., status, elapsedTime}]} for short course races created *this session*
        let currentSeries = null;
        let currentRace = null; // Race number for standard series
        let editMode = false; // For standard races, loading saved data
        let directEditMode = false;
        let resultBeingEdited = null; // Store original state for direct edit cancel

        // --- DOM Elements ---
        const loadingOverlay = document.getElementById('loading-overlay');
        // Tabs & Buttons
        const seriesTab = document.getElementById('series-tab');
        const raceTab = document.getElementById('race-tab');
        const resultsTab = document.getElementById('results-tab');
        const seriesResultsTab = document.getElementById('series-results-tab');
        const raceViewTab = document.getElementById('race-view-tab');
        const boatListTab = document.getElementById('boat-list-tab');
        const btnSeries = document.getElementById('btn-series');
        const btnRace = document.getElementById('btn-race');
        const btnResults = document.getElementById('btn-results');
        const btnSeriesResults = document.getElementById('btn-series-results');
        const btnRaceView = document.getElementById('btn-race-view');
        const btnBoatList = document.getElementById('btn-boat-list');

        // Race Entry Form Elements
        const entryFormTitle = document.getElementById('entry-form-title');
        const sailNumber = document.getElementById('sail-number');
        const boatClassSelect = document.getElementById('boat-class');
        const skipperName = document.getElementById('skipper');
        const yardstickValue = document.getElementById('yardstick');
        const elapsedTime = document.getElementById('elapsed-time');
        const timeInputs = document.getElementById('time-inputs');
        const statusRadios = document.querySelectorAll('input[name="race-status"]');
        const manualClassCheck = document.getElementById('manual-class-check');
        const manualClassInput = document.getElementById('manual-class-input');
        const manualBoatClass = document.getElementById('manual-boat-class');
        const manualYardstickCheck = document.getElementById('manual-yardstick-check');
        const addBoatBtn = document.getElementById('add-boat');
        const updateBoatBtn = document.getElementById('update-boat');
        const cancelUpdateBtn = document.getElementById('cancel-update');
        const clearFormBtn = document.getElementById('clear-form');
        const editingEntryIndexInput = document.getElementById('editing-entry-index');
        const editingShortCourseRaceIndexInput = document.getElementById('editing-short-course-race-index'); // For editing within short course race
        const entriesBody = document.getElementById('entries-body'); // Standard entries table body
        const calculateResultsBtn = document.getElementById('calculate-results');
        const clearAllBtn = document.getElementById('clear-all');
        const editModeWarning = document.getElementById('edit-mode-warning');
        const selectSavedBoat = document.getElementById('select-saved-boat');
        const standardEntryFields = document.getElementById('standard-entry-fields'); // Wrapper for status/time
        const raceSelectorWrapper = document.getElementById('race-selector-wrapper'); // Wrapper for race dropdown label/select

        // Standard Race UI Elements
        const standardEntriesDisplay = document.getElementById('standard-entries-display');
        const currentEntriesHeading = document.getElementById('current-entries-heading');

        // Short Course UI Elements
        const shortCourseStagingDisplay = document.getElementById('short-course-staging-display');
        const shortCoursePoolHeading = document.getElementById('short-course-pool-heading');
        const shortCoursePoolBody = document.getElementById('short-course-pool-body');
        const createShortCourseRaceBtn = document.getElementById('create-short-course-race-btn');
        const shortCourseRacesContainer = document.getElementById('short-course-races-container');
        const clearShortCourseSessionBtn = document.getElementById('clear-short-course-session-btn');

        // Series/Race Selection Dropdowns
        const selectSeries = document.getElementById('select-series');
        const selectRace = document.getElementById('select-race');
        const resultsSeries = document.getElementById('results-series-select');
        const resultsRace = document.getElementById('results-race-select');
        const viewSeries = document.getElementById('view-series-select');
        const viewAllSeries = document.getElementById('view-all-series-select');

        // Results Tab Elements
        const resultsBody = document.getElementById('results-body');
        const resultRaceInfo = document.getElementById('result-race-info');
        const saveResultsTabBtn = document.getElementById('save-results-tab-btn');
        const editRaceEntriesBtn = document.getElementById('edit-race-entries');
        const editResultsDirectlyBtn = document.getElementById('edit-results-directly');
        const directEditWarning = document.getElementById('direct-edit-warning');

        // Series Results Tab Elements
        const seriesResultsBody = document.getElementById('series-results-body');
        const seriesResultsHeader = document.getElementById('series-results-header');
        const seriesSummary = document.getElementById('series-summary');
        const legendDiv = document.querySelector('.legend');

        // Race Viewer Tab Elements
        const raceSummaryView = document.getElementById('race-summary-view');
        const raceSelector = document.querySelector('.race-selector');
        const individualRaceInfo = document.getElementById('individual-race-info');
        const individualRaceBody = document.getElementById('individual-race-body');
        const individualRaceHeader = document.querySelector('#individual-race-results thead');
        if (individualRaceHeader) {
            individualRaceHeader.innerHTML = '<tr><th>Pos</th><th>Sail No</th><th>Boat Type</th><th>Helm</th><th>YS</th><th>Finish</th><th>Elapsed</th><th>Corrected</th><th>Points</th></tr>';
        }

        // Series Management Form Elements
        const createSeriesBtn = document.getElementById('create-series-btn');
        const saveSeriesBtn = document.getElementById('save-series-btn');
        const cancelSeriesBtn = document.getElementById('cancel-series-btn');
        const seriesName = document.getElementById('series-name');
        const seriesShortCourseCheck = document.getElementById('series-short-course'); // Short Course checkbox
        const standardSeriesOptions = document.getElementById('standard-series-options'); // Wrapper div
        const numberOfRaces = document.getElementById('number-of-races');
        const racesPerDiscardInput = document.getElementById('races-per-discard');
        const editSeriesId = document.getElementById('edit-series-id');
        const createSeriesForm = document.getElementById('create-series-form');
        const seriesList = document.getElementById('series-list');

        // Edit Result Form (Direct) Elements
        const editResultForm = document.getElementById('edit-result-form');
        const editResultLabel = document.getElementById('edit-result-label');
        const editStatusDirect = document.getElementById('edit-status-direct');
        const editTimeInputsDirect = document.getElementById('edit-time-inputs-direct');
        const editElapsedTimeDirect = document.getElementById('edit-elapsed-time-direct');
        const editPositionDirect = document.getElementById('edit-position-direct');
        const editPointsDirect = document.getElementById('edit-points-direct');
        const editResultIndex = document.getElementById('edit-result-index');
        const saveEditResult = document.getElementById('save-edit-result');
        const cancelEditResult = document.getElementById('cancel-edit-result');
         if (editStatusDirect && editStatusDirect.options.length === 0) {
             const statuses = ['finished', 'DNF', 'DNS', 'OCS', 'DSQ', 'OOD'];
             statuses.forEach(status => {
                 const option = document.createElement('option'); option.value = status; option.textContent = status.toUpperCase(); editStatusDirect.appendChild(option);
             });
         }

        // Boat List Tab Elements
        const showAddBoatFormBtn = document.getElementById('show-add-boat-form-btn');
        const boatListForm = document.getElementById('boat-list-form');
        const boatFormTitle = document.getElementById('boat-form-title');
        const boatSailNumber = document.getElementById('boat-sail-number');
        const boatClassList = document.getElementById('boat-class-list');
        const boatManualClassCheck = document.getElementById('boat-manual-class-check');
        const boatManualClassInput = document.getElementById('boat-manual-class-input');
        const boatManualBoatClass = document.getElementById('boat-manual-boat-class');
        const boatSkipper = document.getElementById('boat-skipper');
        const boatYardstick = document.getElementById('boat-yardstick');
        const boatManualYardstickCheck = document.getElementById('boat-manual-yardstick-check');
        const editingBoatId = document.getElementById('editing-boat-id');
        const saveBoatListBtn = document.getElementById('save-boat-list-btn');
        const cancelBoatListBtn = document.getElementById('cancel-boat-list-btn');
        const boatListTable = document.getElementById('boat-list-table');
        const boatListBody = document.getElementById('boat-list-body');

        // Export/Import Elements
        const exportAllDataBtn = document.getElementById('export-all-data-btn');
        const importDataBtn = document.getElementById('import-data-btn');
        const importFileInput = document.getElementById('import-file-input');
        const exportBoatListBtn = document.getElementById('export-boat-list-btn');
        const importBoatListBtn = document.getElementById('import-boat-list-btn');
        const importBoatListFileInput = document.getElementById('import-boat-list-file-input');


        // --- Utility Functions ---
        function isValidTimeFormat(timeStr) { if (!timeStr) return false; const regex = /^([0-9]{1,2}):([0-5][0-9]):([0-5][0-9])$/; return regex.test(timeStr); }
        function timeToSeconds(timeStr) { if (!isValidTimeFormat(timeStr)) return 0; const [hours, minutes, seconds] = timeStr.split(':').map(Number); return hours * 3600 + minutes * 60 + seconds; }
        function secondsToTime(seconds) { if (isNaN(seconds) || seconds === null || seconds < 0) return ''; seconds = Math.round(seconds); const hours = Math.floor(seconds / 3600); let minutes = Math.floor((seconds % 3600) / 60); let secs = seconds % 60; if (secs === 60) { minutes += 1; secs = 0; } if (minutes === 60) { /* hours += 1; */ minutes = 0; } return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`; }
        // Simple pluralize helper
        function pluralize(count, singular, plural = null) { return count === 1 ? singular : (plural || singular + 's'); }


        // --- Tab Navigation ---
        function setActiveTab(tabElement) {
             document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active-tab'));
             document.querySelectorAll('.tab-buttons button').forEach(btn => btn.classList.remove('active-button'));

             if (tabElement) {
                 tabElement.classList.add('active-tab');
                 const buttonId = 'btn-' + tabElement.id.replace('-tab', '');
                 const correspondingButton = document.getElementById(buttonId);
                 if(correspondingButton) { correspondingButton.classList.add('active-button'); }
                 else { console.warn("Could not find button for tab:", buttonId); }
             } else { console.error("setActiveTab called with null element"); }

             // Reset modes/warnings when switching tabs
             if (tabElement?.id !== 'results-tab') { disableDirectEditMode(); }
             if (tabElement?.id !== 'race-tab') {
                editMode = false;
                editModeWarning?.classList.add('hidden');
                // Clear short course session data if navigating away from Race Entry tab
                if (shortCourseSessionRaces.length > 0) {
                    console.log("Navigating away from Race Entry tab, clearing short course session.");
                    clearShortCourseSessionData();
                }
             }
             // Use hidden class consistently
             if (tabElement?.id !== 'boat-list-tab') { boatListForm?.classList.add('hidden'); }
             if (tabElement?.id !== 'series-tab') { createSeriesForm?.classList.add('hidden'); }

         }
        if(btnBoatList) btnBoatList.addEventListener('click', () => setActiveTab(boatListTab));
        if(btnSeries) btnSeries.addEventListener('click', () => setActiveTab(seriesTab));
        if(btnRace) btnRace.addEventListener('click', () => setActiveTab(raceTab));
        if(btnResults) btnResults.addEventListener('click', () => setActiveTab(resultsTab));
        if(btnSeriesResults) btnSeriesResults.addEventListener('click', () => { setActiveTab(seriesResultsTab); if (viewSeries?.value) calculateSeriesResults(); });
        if(btnRaceView) btnRaceView.addEventListener('click', () => { setActiveTab(raceViewTab); if (viewAllSeries?.value) displayRaceViewer(); });


        // --- Yardstick Functions ---
        function initYardsticks() {
            yardstickData.sort((a, b) => a.boatClass.localeCompare(b.boatClass));
            const populateSelect = (selectElement) => {
                 if (!selectElement) return;
                 selectElement.innerHTML = '<option value="">Select boat class</option>';
                 yardstickData.forEach(boat => {
                     const option = document.createElement('option');
                     option.value = boat.boatClass;
                     option.textContent = `${boat.boatClass} (${boat.yardstick})`;
                     selectElement.appendChild(option);
                 });
            }
            populateSelect(boatClassSelect); // Race entry
            populateSelect(boatClassList); // Boat list management
        }

        // --- Boat List Functions ---
        function renderBoatListTable() {
            if (!boatListBody) return;
            boatListBody.innerHTML = '';
            boatList.sort((a, b) => a.sailNumber.localeCompare(b.sailNumber));

             if (boatList.length === 0) {
                  const row = boatListBody.insertRow();
                  const cell = row.insertCell(); cell.colSpan = 5;
                  cell.textContent = 'No boats saved yet. Click "Add New Boat" to start.';
                  cell.style.textAlign = 'center'; cell.style.fontStyle = 'italic'; cell.style.color = '#666';
                  return;
             }

            boatList.forEach(boat => {
                const row = boatListBody.insertRow();
                row.innerHTML = `
                    <td>${boat.sailNumber}</td>
                    <td>${boat.boatClass}</td>
                    <td>${boat.skipper}</td>
                    <td>${boat.yardstick}</td>
                    <td class="actions">
                        <button class="btn-edit" onclick="editBoatInList(${boat.id})">Edit</button>
                        <button class="btn-danger" onclick="deleteBoatFromList(${boat.id})">Delete</button>
                    </td>
                `;
            });
            populateSavedBoatDropdown();
        }
        function clearBoatListForm() {
            if (!boatListForm) return;
            if(boatSailNumber) boatSailNumber.value = '';
            if(boatClassList) boatClassList.value = '';
            if(boatSkipper) boatSkipper.value = '';
            if(boatYardstick) boatYardstick.value = '';
            if(boatManualBoatClass) boatManualBoatClass.value = '';
            if(editingBoatId) editingBoatId.value = '';
            if(boatManualClassCheck) boatManualClassCheck.checked = false;
            if(boatManualClassInput) boatManualClassInput.classList.add('hidden');
            if(boatClassList) boatClassList.disabled = false;
            if(boatManualYardstickCheck) boatManualYardstickCheck.checked = false;
            if(boatYardstick) boatYardstick.readOnly = true;
            if(boatFormTitle) boatFormTitle.textContent = "Add New Boat";
            boatListForm.classList.add('hidden');
            if(boatClassList) boatClassList.dispatchEvent(new Event('change'));
        }
        if(showAddBoatFormBtn) showAddBoatFormBtn.addEventListener('click', () => {
            clearBoatListForm();
            if(boatFormTitle) boatFormTitle.textContent = "Add New Boat";
            if(boatListForm) boatListForm.classList.remove('hidden');
            if(boatSailNumber) boatSailNumber.focus();
        });
        if(cancelBoatListBtn) cancelBoatListBtn.addEventListener('click', clearBoatListForm);

        if(saveBoatListBtn) saveBoatListBtn.addEventListener('click', async () => { // Made async
            console.log("Attempting to save boat...");
            const id = editingBoatId?.value ? parseInt(editingBoatId.value) : null;
            const sailNum = boatSailNumber?.value.trim().toUpperCase();
            const skipper = boatSkipper?.value.trim();
            const yardstick = parseFloat(boatYardstick?.value);
            const isManualClass = boatManualClassCheck?.checked;
            const boatClass = isManualClass ? boatManualBoatClass?.value.trim() : boatClassList?.value;

            if (!sailNum) { alert("Sail Number is required."); return; }
            if (!boatClass) { alert("Boat Class is required."); return; }
            if (!skipper) { alert("Skipper Name is required."); return; }
            if (isNaN(yardstick) || yardstick <= 0) { alert("Valid positive Yardstick is required."); return; }

            const duplicate = boatList.find(b => b.sailNumber.toUpperCase() === sailNum.toUpperCase() && b.id !== id);
            if (duplicate) {
                alert(`Error: Sail Number "${sailNum}" is already used by ${duplicate.skipper} (${duplicate.boatClass}). Sail Numbers must be unique.`);
                return;
            }

            const boatData = { id: id || Date.now(), sailNumber: sailNum, boatClass: boatClass, skipper: skipper, yardstick: yardstick };

            if (id) {
                const index = boatList.findIndex(b => b.id === id);
                if (index !== -1) { boatList[index] = boatData; }
                else { alert("Error finding boat to update."); return; }
            } else {
                boatList.push(boatData);
            }

            await saveDataToGoogleSheet(); // SAVE TO GOOGLE SHEET
            renderBoatListTable();
            clearBoatListForm();
        });

        function editBoatInList(id) {
            const boat = boatList.find(b => b.id === id);
            if (!boat) return;
            clearBoatListForm();
            if(editingBoatId) editingBoatId.value = boat.id;
            if(boatSailNumber) boatSailNumber.value = boat.sailNumber;
            if(boatSkipper) boatSkipper.value = boat.skipper;
            if(boatYardstick) boatYardstick.value = boat.yardstick;
            if(boatFormTitle) boatFormTitle.textContent = `Edit Boat: ${boat.sailNumber}`;
            const isStandardClass = yardstickData.some(yc => yc.boatClass === boat.boatClass);
            if (isStandardClass && boatClassList && boatClassList.querySelector(`option[value="${boat.boatClass}"]`)) {
                 if(boatManualClassCheck) boatManualClassCheck.checked = false;
                 if(boatClassList) boatClassList.value = boat.boatClass;
                 if(boatManualClassInput) boatManualClassInput.classList.add('hidden');
                 if(boatClassList) boatClassList.disabled = false;
                 if(manualBoatClass) manualBoatClass.value = '';
                 const selectedClassData = yardstickData.find(b => b.boatClass === boatClassList.value);
                 const autoYardstick = selectedClassData ? selectedClassData.yardstick : null;
                 if (autoYardstick !== null && boat.yardstick === autoYardstick) {
                     if(boatManualYardstickCheck) boatManualYardstickCheck.checked = false;
                     if(boatYardstick) boatYardstick.readOnly = true;
                 } else {
                     if(boatManualYardstickCheck) boatManualYardstickCheck.checked = true;
                     if(boatYardstick) boatYardstick.readOnly = false;
                 }
             } else {
                 if(boatManualClassCheck) boatManualClassCheck.checked = true;
                 if(boatManualBoatClass) boatManualBoatClass.value = boat.boatClass;
                 if(boatClassList) boatClassList.value = '';
                 if(boatManualClassInput) boatManualClassInput.classList.remove('hidden');
                 if(boatClassList) boatClassList.disabled = true;
                 if(boatManualYardstickCheck) boatManualYardstickCheck.checked = true;
                 if(boatYardstick) boatYardstick.readOnly = false;
             }
            if(boatListForm) {
                boatListForm.classList.remove('hidden');
                boatListForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
        async function deleteBoatFromList(id) { // Made async
            const boatIndex = boatList.findIndex(b => b.id === id);
            if (boatIndex === -1) return;
            const boat = boatList[boatIndex];
            if (confirm(`Are you sure you want to delete ${boat.sailNumber} (${boat.skipper}) from the saved boat list?`)) {
                boatList.splice(boatIndex, 1);
                await saveDataToGoogleSheet(); // SAVE TO GOOGLE SHEET
                renderBoatListTable();
            }
        }
        // Link Boat List form controls to Yardstick Data
        if(boatClassList) boatClassList.addEventListener('change', () => {
            const selectedClass = boatClassList.value;
            if (selectedClass && boatManualYardstickCheck && !boatManualYardstickCheck.checked) {
                const boatData = yardstickData.find(boat => boat.boatClass === selectedClass);
                if(boatYardstick) { boatYardstick.value = boatData ? boatData.yardstick : ''; boatYardstick.readOnly = true; }
            } else if (!selectedClass && boatManualYardstickCheck && !boatManualYardstickCheck.checked) {
                 if(boatYardstick) { boatYardstick.value = ''; boatYardstick.readOnly = true; }
            } else if (boatManualYardstickCheck && boatManualYardstickCheck.checked) {
                 if(boatYardstick) boatYardstick.readOnly = false;
            }
        });
        if(boatManualClassCheck) boatManualClassCheck.addEventListener('change', () => {
            const isManual = boatManualClassCheck.checked;
            if(boatClassList) boatClassList.disabled = isManual;
            if(boatManualClassInput) boatManualClassInput.classList.toggle('hidden', !isManual);
            if (!isManual) {
                if(manualBoatClass) manualBoatClass.value = '';
                if(boatClassList) boatClassList.dispatchEvent(new Event('change'));
            } else {
                 if(boatYardstick) boatYardstick.value = '';
                 if(boatManualYardstickCheck) boatManualYardstickCheck.checked = true;
                 if(boatYardstick) boatYardstick.readOnly = false;
                 if(boatClassList) boatClassList.value = '';
            }
        });
        if(boatManualYardstickCheck) boatManualYardstickCheck.addEventListener('change', () => {
            const isManual = boatManualYardstickCheck.checked;
            if(boatYardstick) boatYardstick.readOnly = isManual;
            if (!isManual && boatManualClassCheck && !boatManualClassCheck.checked) {
                if(boatClassList) boatClassList.dispatchEvent(new Event('change'));
            }
        });


        // --- Race Entry Functions ---
        function populateSavedBoatDropdown() {
            if (!selectSavedBoat) return;
            const currentVal = selectSavedBoat.value;
            selectSavedBoat.innerHTML = '<option value="">-- Select Saved Boat --</option>';
            boatList.sort((a,b) => a.sailNumber.localeCompare(b.sailNumber));
            boatList.forEach(boat => {
                const option = document.createElement('option');
                option.value = boat.id;
                option.textContent = `${boat.sailNumber} - ${boat.skipper} (${boat.boatClass})`;
                selectSavedBoat.appendChild(option);
            });
             if (boatList.some(b => b.id == currentVal)) { selectSavedBoat.value = currentVal; }
        }
        if(selectSavedBoat) selectSavedBoat.addEventListener('change', () => {
            const selectedBoatId = selectSavedBoat.value;
            if (!selectedBoatId) { clearEntryForm(); return; }
            const boat = boatList.find(b => b.id == selectedBoatId);
            if (boat) {
                if(sailNumber) sailNumber.value = boat.sailNumber;
                if(skipperName) skipperName.value = boat.skipper;
                if(yardstickValue) yardstickValue.value = boat.yardstick;
                const isStandardClass = yardstickData.some(yc => yc.boatClass === boat.boatClass);
                if (isStandardClass && boatClassSelect && boatClassSelect.querySelector(`option[value="${boat.boatClass}"]`)) {
                    if(manualClassCheck) manualClassCheck.checked = false;
                    if(boatClassSelect) boatClassSelect.value = boat.boatClass;
                    if(manualClassInput) manualClassInput.classList.add('hidden');
                    if(boatClassSelect) boatClassSelect.disabled = false;
                    if(manualBoatClass) manualBoatClass.value = '';
                    const selectedClassData = yardstickData.find(b => b.boatClass === boatClassSelect.value);
                    const autoYardstick = selectedClassData ? selectedClassData.yardstick : null;
                    if (autoYardstick !== null && boat.yardstick === autoYardstick) {
                        if(manualYardstickCheck) manualYardstickCheck.checked = false;
                        if(yardstickValue) yardstickValue.readOnly = true;
                    } else {
                        if(manualYardstickCheck) manualYardstickCheck.checked = true;
                        if(yardstickValue) yardstickValue.readOnly = false;
                    }
                } else {
                    if(manualClassCheck) manualClassCheck.checked = true;
                    if(boatClassSelect) boatClassSelect.value = '';
                    if(manualBoatClass) manualBoatClass.value = boat.boatClass;
                    if(manualClassInput) manualClassInput.classList.remove('hidden');
                    if(boatClassSelect) boatClassSelect.disabled = true;
                    if(manualYardstickCheck) manualYardstickCheck.checked = true;
                    if(yardstickValue) yardstickValue.readOnly = false;
                }
                 console.log(`Filled race entry form with data for ${boat.sailNumber}`);
            } else {
                console.warn("Selected saved boat not found in boatList:", selectedBoatId);
                 clearEntryForm();
            }
        });

        function clearEntryForm() {
             if(sailNumber) sailNumber.value = '';
             if(boatClassSelect) boatClassSelect.value = '';
             if(skipperName) skipperName.value = '';
             if(yardstickValue) yardstickValue.value = '';
             if(elapsedTime) elapsedTime.value = '';
             const finishedRadio = document.getElementById('status-finished');
             if(finishedRadio) finishedRadio.checked = true;
             if(manualBoatClass) manualBoatClass.value = '';
             if(editingEntryIndexInput) editingEntryIndexInput.value = '-1';
             if(editingShortCourseRaceIndexInput) editingShortCourseRaceIndexInput.value = '-1';
             if(manualClassCheck) manualClassCheck.checked = false;
             if(manualClassInput) manualClassInput.classList.add('hidden');
             if(boatClassSelect) boatClassSelect.disabled = false;
             if(manualYardstickCheck) manualYardstickCheck.checked = false;
             if(yardstickValue) yardstickValue.readOnly = true;
             if(addBoatBtn) addBoatBtn.style.display = 'inline-block';
             if(updateBoatBtn) updateBoatBtn.classList.add('hidden');
             if(cancelUpdateBtn) cancelUpdateBtn.classList.add('hidden');
             if(selectSavedBoat) selectSavedBoat.value = '';
             if(boatClassSelect) boatClassSelect.dispatchEvent(new Event('change'));
             if(manualClassCheck) manualClassCheck.dispatchEvent(new Event('change'));
             if(manualYardstickCheck) manualYardstickCheck.dispatchEvent(new Event('change'));
             if (statusRadios.length > 0 && standardEntryFields && !standardEntryFields.classList.contains('hidden')) {
                handleStatusChange();
            }
         }

        // --- Event Listeners for Race Entry Form Class/Yardstick (apply to both modes) ---
         if(boatClassSelect) boatClassSelect.addEventListener('change', () => {
             const selectedClass = boatClassSelect.value;
             const isYardstickManual = manualYardstickCheck?.checked;
             if (selectedClass && !isYardstickManual) {
                 const boatData = yardstickData.find(boat => boat.boatClass === selectedClass);
                 if(yardstickValue) {
                     yardstickValue.value = boatData ? boatData.yardstick : '';
                     yardstickValue.readOnly = true;
                 }
             } else if (!selectedClass && !isYardstickManual) {
                  if(yardstickValue) {
                      yardstickValue.value = '';
                      yardstickValue.readOnly = true;
                  }
             } else if (isYardstickManual) {
                  if(yardstickValue) yardstickValue.readOnly = false;
             }
         });
         if(manualClassCheck) manualClassCheck.addEventListener('change', () => {
             const isManual = manualClassCheck.checked;
             if(boatClassSelect) boatClassSelect.disabled = isManual;
             if(manualClassInput) manualClassInput.classList.toggle('hidden', !isManual);
             if (!isManual) {
                 if(manualBoatClass) manualBoatClass.value = '';
                 if(boatClassSelect) boatClassSelect.dispatchEvent(new Event('change'));
             } else {
                  if(boatClassSelect) boatClassSelect.value = '';
                  if(yardstickValue) yardstickValue.value = '';
                  if(manualYardstickCheck) manualYardstickCheck.checked = true;
                  if(yardstickValue) yardstickValue.readOnly = false;
                  if(manualBoatClass) manualBoatClass.focus();
             }
         });
         if(manualYardstickCheck) manualYardstickCheck.addEventListener('change', () => {
             const isManual = manualYardstickCheck.checked;
             if(yardstickValue) yardstickValue.readOnly = isManual;
             if (!isManual && manualClassCheck && !manualClassCheck.checked && boatClassSelect) {
                 boatClassSelect.dispatchEvent(new Event('change'));
             } else if (!isManual && (!manualClassCheck || manualClassCheck.checked)) {
                 if(yardstickValue) yardstickValue.value = '';
             }
         });
        function handleStatusChange() { // Only for standard entry fields
            const selectedStatus = document.querySelector('input[name="race-status"]:checked')?.value;
            if(timeInputs) timeInputs.style.display = (selectedStatus === 'finished') ? 'block' : 'none';
            if (selectedStatus !== 'finished' && elapsedTime) elapsedTime.value = '';
        }
        statusRadios.forEach(radio => radio.addEventListener('change', handleStatusChange));

        // --- Add/Update/Remove Entries ---
        if(addBoatBtn) addBoatBtn.addEventListener('click', () => {
            const entryData = getEntryFormData();
            if (!entryData) return;

            if (currentSeries?.isShortCourse) {
                // Check for duplicate sail number in the pool
                if (entries.some(e => e.sailNumber.toUpperCase() === entryData.sailNumber.toUpperCase())) {
                    alert(`Boat with Sail Number ${entryData.sailNumber} is already in the pool.`);
                    return;
                }
                entries.push(entryData); // Add to pool
                renderShortCoursePoolTable(); // Render pool table
            } else {
                 // Standard Race: Check for duplicate sail number in this race
                 if (!currentRace) { alert("Please select a race number before adding boats."); return; }
                if (entries.some(e => e.sailNumber.toUpperCase() === entryData.sailNumber.toUpperCase())) {
                    alert(`Boat with Sail Number ${entryData.sailNumber} is already entered in this race.`);
                    return;
                }
                entries.push(entryData); // Add to standard race list
                renderEntriesTable(); // Render standard table
            }
            clearEntryForm();
            if(sailNumber) sailNumber.focus();
        });

        if(updateBoatBtn) updateBoatBtn.addEventListener('click', () => {
            const entryData = getEntryFormData();
            if (!entryData) return;

            const index = parseInt(editingEntryIndexInput?.value);
            const shortCourseRaceIndex = parseInt(editingShortCourseRaceIndexInput?.value);

            if (currentSeries?.isShortCourse) {
                if (shortCourseRaceIndex >= 0 && shortCourseRaceIndex < shortCourseSessionRaces.length && index >= 0 && index < shortCourseSessionRaces[shortCourseRaceIndex].entries.length) {
                    const raceEntries = shortCourseSessionRaces[shortCourseRaceIndex].entries;
                    if (raceEntries.some((e, i) => i !== index && e.sailNumber.toUpperCase() === entryData.sailNumber.toUpperCase())) {
                        alert(`Boat with Sail Number ${entryData.sailNumber} is already entered in this race.`);
                        return;
                    }
                    shortCourseSessionRaces[shortCourseRaceIndex].entries[index] = {
                        ...entryData,
                        status: document.querySelector('input[name="race-status"]:checked')?.value || 'finished',
                        elapsedTime: elapsedTime.value || ''
                    };
                    renderShortCourseSessionRaces();
                    clearEntryForm();
                    switchToShortCourseUI();
                }
                else if (shortCourseRaceIndex === -1 && index >= 0 && index < entries.length) {
                    if (entries.some((e, i) => i !== index && e.sailNumber.toUpperCase() === entryData.sailNumber.toUpperCase())) {
                        alert(`Boat with Sail Number ${entryData.sailNumber} is already in the pool.`);
                        return;
                    }
                    entries[index] = {
                        sailNumber: entryData.sailNumber,
                        boatClass: entryData.boatClass,
                        skipper: entryData.skipper,
                        yardstick: entryData.yardstick,
                        status: 'pool',
                        elapsedTime: ''
                     };
                    renderShortCoursePoolTable();
                    clearEntryForm();
                    switchToShortCourseUI();
                }
                 else { alert('Error updating short course entry. Index out of bounds.'); clearEntryForm(); switchToShortCourseUI(); }
            } else {
                if (!currentRace) { alert("Error: No standard race selected for update."); return; }
                if (index >= 0 && index < entries.length) {
                    if (entries.some((e, i) => i !== index && e.sailNumber.toUpperCase() === entryData.sailNumber.toUpperCase())) {
                        alert(`Boat with Sail Number ${entryData.sailNumber} is already entered in this race.`);
                        return;
                    }
                    entries[index] = entryData;
                    renderEntriesTable();
                    clearEntryForm();
                } else { alert('Error updating standard entry. Index out of bounds.'); clearEntryForm(); }
            }
        });

        if(cancelUpdateBtn) cancelUpdateBtn.addEventListener('click', () => {
            clearEntryForm();
            if (currentSeries?.isShortCourse) {
                switchToShortCourseUI();
            } else {
                switchToStandardRaceUI();
            }
        });

        function getEntryFormData() {
            const sailNum = sailNumber?.value.trim().toUpperCase();
            let boatClass = manualClassCheck?.checked ? manualBoatClass?.value.trim() : boatClassSelect?.value;
            const skipper = skipperName?.value.trim();
            const yardstick = parseFloat(yardstickValue?.value);

            if (!sailNum) { alert('Sail Number required.'); return null; }
            if (!boatClass) { alert('Boat Class required.'); return null; }
            if (!skipper) { alert('Skipper Name required.'); return null; }
            if (isNaN(yardstick) || yardstick <= 0) { alert('Valid positive Yardstick required.'); return null; }

            let status = 'finished';
            let elapsed = '';

             const standardFieldsVisible = standardEntryFields && !standardEntryFields.classList.contains('hidden');
             if (standardFieldsVisible) {
                 status = document.querySelector('input[name="race-status"]:checked')?.value;
                 elapsed = elapsedTime?.value.trim();

                 if (!status) { alert('Race Status required.'); return null; }
                 if (status === 'finished') { if (!isValidTimeFormat(elapsed)) { alert('Valid elapsed time (hh:mm:ss) required for finished status.'); return null; } }
                 else { elapsed = ''; }
             } else {
                status = '';
                elapsed = '';
             }
            return { sailNumber: sailNum, boatClass, skipper, yardstick, status, elapsedTime: elapsed };
        }

        function renderEntriesTable() {
            if (!entriesBody) return;
            entriesBody.innerHTML = '';
             const raceNumText = currentRace ? ` Race ${currentRace}` : '';
             if(currentEntriesHeading) currentEntriesHeading.textContent = `Current Entries for Selected${raceNumText}`;

            if (entries.length === 0) {
                const row = entriesBody.insertRow(); const cell = row.insertCell();
                cell.colSpan = 7; cell.textContent = currentRace ? 'No entries added yet for this race.' : 'Select a race to view/add entries.';
                cell.style.textAlign = 'center'; cell.style.fontStyle = 'italic'; cell.style.color = '#666'; return;
            }
            entries.forEach((entry, index) => {
                const row = entriesBody.insertRow();
                row.innerHTML = `<td>${entry.sailNumber}</td><td>${entry.boatClass}</td><td>${entry.skipper}</td><td>${entry.yardstick}</td><td>${entry.status.toUpperCase()}</td><td>${entry.elapsedTime || '-'}</td><td class="actions"><button class="btn-edit" onclick="editEntry(${index})">Edit</button><button class="btn-danger" onclick="removeEntry(${index})">Rem</button></td>`;
            });
        }

        function renderShortCoursePoolTable() {
            if (!shortCoursePoolBody) return;
            shortCoursePoolBody.innerHTML = '';
             const poolCount = entries.length;
             if(shortCoursePoolHeading) shortCoursePoolHeading.textContent = `Race Entries (${poolCount} ${pluralize(poolCount, 'Boat')})`;

            if (poolCount === 0) {
                const row = shortCoursePoolBody.insertRow(); const cell = row.insertCell();
                cell.colSpan = 5; cell.textContent = 'Add boats using the form above to create the pool for the next race.';
                cell.style.textAlign = 'center'; cell.style.fontStyle = 'italic'; cell.style.color = '#666'; return;
            }
            entries.forEach((entry, index) => {
                const row = shortCoursePoolBody.insertRow();
                row.innerHTML = `<td>${entry.sailNumber}</td><td>${entry.boatClass}</td><td>${entry.skipper}</td><td>${entry.yardstick}</td><td class="actions"><button class="btn-edit" onclick="editEntry(${index})">Edit</button><button class="btn-danger" onclick="removeEntry(${index})">Rem</button></td>`;
            });
        }

        function editEntry(index) {
            let entry;
            let editingTarget = '';

            if (currentSeries?.isShortCourse) {
                 if (index >= 0 && index < entries.length) {
                     entry = entries[index];
                     editingTarget = 'pool';
                 } else { return; }
                 if (editingShortCourseRaceIndexInput) editingShortCourseRaceIndexInput.value = -1;
            } else {
                 if (!currentRace) { console.error("Attempting to edit standard entry with no race selected."); return; }
                 if (index >= 0 && index < entries.length) {
                     entry = entries[index];
                     editingTarget = 'standard';
                 } else { return; }
            }

            if (!entry) return;

            clearEntryForm();
            if(sailNumber) sailNumber.value = entry.sailNumber;
            if(skipperName) skipperName.value = entry.skipper;
            if(yardstickValue) yardstickValue.value = entry.yardstick;
            if(editingEntryIndexInput) editingEntryIndexInput.value = index;

            if (editingTarget === 'standard') {
                 if(elapsedTime) elapsedTime.value = entry.elapsedTime || ''; // ensure string
                 try { const statusRadio = document.getElementById(`status-${entry.status.toLowerCase()}`); if(statusRadio) statusRadio.checked = true; handleStatusChange(); } catch (e) { console.warn("Status ID not found:", entry.status); }
                 if (standardEntryFields) standardEntryFields.classList.remove('hidden');
            } else {
                 if (standardEntryFields) standardEntryFields.classList.add('hidden');
            }

            const isStandardClass = yardstickData.some(yc => yc.boatClass === entry.boatClass);
            if (isStandardClass && boatClassSelect && boatClassSelect.querySelector(`option[value="${entry.boatClass}"]`)) {
                if(manualClassCheck) manualClassCheck.checked = false;
                if(boatClassSelect) boatClassSelect.value = entry.boatClass;
                if(manualClassInput) manualClassInput.classList.add('hidden');
                if(boatClassSelect) boatClassSelect.disabled = false;
                if(manualBoatClass) manualBoatClass.value = '';
                const boatData = yardstickData.find(b => b.boatClass === boatClassSelect.value);
                const autoYardstick = boatData ? boatData.yardstick : null;
                if (autoYardstick !== null && entry.yardstick === autoYardstick) {
                    if(manualYardstickCheck) manualYardstickCheck.checked = false;
                    if(yardstickValue) yardstickValue.readOnly = true;
                } else {
                    if(manualYardstickCheck) manualYardstickCheck.checked = true;
                    if(yardstickValue) yardstickValue.readOnly = false;
                }
            } else {
                 if(manualClassCheck) manualClassCheck.checked = true;
                 if(manualBoatClass) manualBoatClass.value = entry.boatClass;
                 if(boatClassSelect) boatClassSelect.value = '';
                 if(manualClassInput) manualClassInput.classList.remove('hidden');
                 if(boatClassSelect) boatClassSelect.disabled = true;
                 if(manualYardstickCheck) manualYardstickCheck.checked = true;
                 if(yardstickValue) yardstickValue.readOnly = false;
            }

            if(addBoatBtn) addBoatBtn.style.display = 'none';
            if(updateBoatBtn) updateBoatBtn.classList.remove('hidden');
            if(cancelUpdateBtn) cancelUpdateBtn.classList.remove('hidden');
            if(sailNumber) { sailNumber.focus(); sailNumber.scrollIntoView({ behavior: 'smooth', block: 'center' }); }
        }

        function editShortCourseEntry(raceIndex, entryIndex) {
            if (!currentSeries?.isShortCourse || raceIndex < 0 || raceIndex >= shortCourseSessionRaces.length || entryIndex < 0 || entryIndex >= shortCourseSessionRaces[raceIndex].entries.length) {
                console.error("Invalid indices for editShortCourseEntry:", raceIndex, entryIndex);
                return;
            }
            const entry = shortCourseSessionRaces[raceIndex].entries[entryIndex];
            if (!entry) return;

            clearEntryForm();
            if(sailNumber) sailNumber.value = entry.sailNumber;
            if(skipperName) skipperName.value = entry.skipper;
            if(yardstickValue) yardstickValue.value = entry.yardstick;
            if(editingEntryIndexInput) editingEntryIndexInput.value = entryIndex;
            if(editingShortCourseRaceIndexInput) editingShortCourseRaceIndexInput.value = raceIndex;

            if(elapsedTime) elapsedTime.value = entry.elapsedTime || '';
            try {
                const statusRadio = document.getElementById(`status-${entry.status.toLowerCase()}`);
                if(statusRadio) statusRadio.checked = true; else document.getElementById('status-finished').checked = true;
                handleStatusChange();
            } catch (e) { console.warn("Status ID not found:", entry.status); if(document.getElementById('status-finished')) document.getElementById('status-finished').checked = true; handleStatusChange(); }
            if (standardEntryFields) standardEntryFields.classList.remove('hidden');

             const isStandardClass = yardstickData.some(yc => yc.boatClass === entry.boatClass);
             if (isStandardClass && boatClassSelect && boatClassSelect.querySelector(`option[value="${entry.boatClass}"]`)) {
                 if(manualClassCheck) manualClassCheck.checked = false;
                 if(boatClassSelect) boatClassSelect.value = entry.boatClass;
                 if(manualClassInput) manualClassInput.classList.add('hidden');
                 if(boatClassSelect) boatClassSelect.disabled = false;
                 if(manualBoatClass) manualBoatClass.value = '';
                 const boatData = yardstickData.find(b => b.boatClass === boatClassSelect.value);
                 const autoYardstick = boatData ? boatData.yardstick : null;
                 if (autoYardstick !== null && entry.yardstick === autoYardstick) {
                     if(manualYardstickCheck) manualYardstickCheck.checked = false;
                     if(yardstickValue) yardstickValue.readOnly = true;
                 } else {
                     if(manualYardstickCheck) manualYardstickCheck.checked = true;
                     if(yardstickValue) yardstickValue.readOnly = false;
                 }
             } else {
                 if(manualClassCheck) manualClassCheck.checked = true;
                 if(manualBoatClass) manualBoatClass.value = entry.boatClass;
                 if(boatClassSelect) boatClassSelect.value = '';
                 if(manualClassInput) manualClassInput.classList.remove('hidden');
                 if(boatClassSelect) boatClassSelect.disabled = true;
                 if(manualYardstickCheck) manualYardstickCheck.checked = true;
                 if(yardstickValue) yardstickValue.readOnly = false;
             }

            if(addBoatBtn) addBoatBtn.style.display = 'none';
            if(updateBoatBtn) updateBoatBtn.classList.remove('hidden');
            if(cancelUpdateBtn) cancelUpdateBtn.classList.remove('hidden');
            if(sailNumber) { sailNumber.focus(); sailNumber.scrollIntoView({ behavior: 'smooth', block: 'center' }); }
        }

        function removeEntry(index) {
            let targetArray;
            let renderFunction;

            if (currentSeries?.isShortCourse) {
                targetArray = entries;
                renderFunction = renderShortCoursePoolTable;
            } else {
                 if (!currentRace) { console.error("Attempting to remove standard entry with no race selected."); return; }
                targetArray = entries;
                renderFunction = renderEntriesTable;
            }

            if (index < 0 || index >= targetArray.length) return;
            if (confirm(`Remove entry for ${targetArray[index]?.sailNumber || 'this boat'}?`)) {
                targetArray.splice(index, 1);
                renderFunction();
                if (editingEntryIndexInput && parseInt(editingEntryIndexInput.value) === index && parseInt(editingShortCourseRaceIndexInput?.value) === -1) {
                    clearEntryForm();
                    if (currentSeries?.isShortCourse) switchToShortCourseUI(); else switchToStandardRaceUI();
                }
            }
        }

         function removeShortCourseEntry(raceIndex, entryIndex) {
            if (!currentSeries?.isShortCourse || raceIndex < 0 || raceIndex >= shortCourseSessionRaces.length || entryIndex < 0 || entryIndex >= shortCourseSessionRaces[raceIndex].entries.length) {
                console.error("Invalid indices for removeShortCourseEntry:", raceIndex, entryIndex);
                return;
            }
            const entry = shortCourseSessionRaces[raceIndex].entries[entryIndex];
            if (confirm(`Remove entry for ${entry?.sailNumber || 'this boat'} from Race ${raceIndex + 1}?`)) {
                shortCourseSessionRaces[raceIndex].entries.splice(entryIndex, 1);
                renderShortCourseSessionRaces();
                 if (editingEntryIndexInput && parseInt(editingEntryIndexInput.value) === entryIndex && editingShortCourseRaceIndexInput && parseInt(editingShortCourseRaceIndexInput.value) === raceIndex) {
                    clearEntryForm();
                    switchToShortCourseUI();
                 }
            }
         }


        if(clearAllBtn) clearAllBtn.addEventListener('click', () => {
            if (currentSeries?.isShortCourse) {
                if (entries.length === 0) { alert("Boat pool is already empty."); return; }
                if (confirm('Clear all boats from the Race Entries? (Does not affect created races).')) {
                    entries = [];
                    renderShortCoursePoolTable();
                    clearEntryForm();
                }
            } else {
                 if (!currentRace) { alert("Please select a race before clearing entries."); return; }
                if (entries.length === 0) { alert("Entry list is already empty for this race."); return; }
                if (confirm(`Clear all current entries in this list for Race ${currentRace}? (Does not affect saved data).`)) {
                    entries = [];
                    renderEntriesTable();
                    clearEntryForm();
                }
            }
        });
        if(clearFormBtn) clearFormBtn.addEventListener('click', () => {
             clearEntryForm();
             if (currentSeries?.isShortCourse) {
                 switchToShortCourseUI();
             } else {
                 switchToStandardRaceUI();
             }
        });

        // --- Short Course Specific Functions ---
        if (createShortCourseRaceBtn) createShortCourseRaceBtn.addEventListener('click', () => {
            if (entries.length === 0) {
                alert("The 'Race Entries' is empty. Add boats before creating a race.");
                return;
            }
            if (!currentSeries || !currentSeries.isShortCourse) {
                 alert("Error: Cannot create short course race - current series is not set or not a short course series.");
                 return;
            }
            const nextRaceNumber = shortCourseSessionRaces.length + 1;
            const raceEntries = JSON.parse(JSON.stringify(entries)).map(entry => ({
                ...entry,
                status: 'finished',
                elapsedTime: ''
            }));
            shortCourseSessionRaces.push({
                raceNumber: nextRaceNumber,
                entries: raceEntries
            });
            renderShortCourseSessionRaces();
            updateCreateRaceButton();
        });

        function renderShortCourseSessionRaces() {
            if (!shortCourseRacesContainer) return;
            shortCourseRacesContainer.innerHTML = '<h3>Created Races (This Session)</h3>';

            if (shortCourseSessionRaces.length === 0) {
                 shortCourseRacesContainer.innerHTML += '<p>No races created yet in this session.</p>';
                 return;
            }
            shortCourseSessionRaces.forEach((raceData, raceIndex) => {
                const raceSection = document.createElement('div');
                raceSection.classList.add('short-course-race-section');
                raceSection.dataset.raceIndex = raceIndex;
                let tableHTML = `<h4>Race ${raceData.raceNumber} (${raceData.entries.length} ${pluralize(raceData.entries.length, 'Boat')})</h4>
                    <div style="overflow-x: auto;">
                    <table class="short-course-race-table">
                        <thead>
                            <tr><th>Sail #</th><th>Boat Class</th><th>Skipper</th><th>Yardstick</th><th>Status</th><th>Elapsed Time</th><th>Actions</th></tr>
                        </thead>
                        <tbody>`;
                raceData.entries.forEach((entry, entryIndex) => {
                    const statusOptions = ['finished', 'DNF', 'DNS', 'OCS', 'DSQ', 'OOD']
                        .map(s => `<option value="${s}" ${entry.status === s ? 'selected' : ''}>${s.toUpperCase()}</option>`)
                        .join('');
                    tableHTML += `
                        <tr data-entry-index="${entryIndex}">
                            <td>${entry.sailNumber}</td>
                            <td>${entry.boatClass}</td>
                            <td>${entry.skipper}</td>
                            <td>${entry.yardstick}</td>
                            <td class="short-course-race-entry">
                                <select class="sc-status-select" onchange="updateShortCourseEntry(${raceIndex}, ${entryIndex}, 'status', this.value)">
                                    ${statusOptions}
                                </select>
                            </td>
                            <td class="short-course-race-entry">
                                <input type="text" class="sc-time-input" value="${entry.elapsedTime || ''}" placeholder="hh:mm:ss" oninput="updateShortCourseEntry(${raceIndex}, ${entryIndex}, 'elapsedTime', this.value)" ${entry.status !== 'finished' ? 'disabled' : ''}>
                            </td>
                            <td class="actions">
                                <button class="btn-edit" onclick="editShortCourseEntry(${raceIndex}, ${entryIndex})">Edit</button>
                                <button class="btn-danger" onclick="removeShortCourseEntry(${raceIndex}, ${entryIndex})">Rem</button>
                            </td>
                        </tr>`;
                });
                tableHTML += `</tbody></table></div>`;
                raceSection.innerHTML = tableHTML;
                shortCourseRacesContainer.appendChild(raceSection);
            });
        }

        function updateShortCourseEntry(raceIndex, entryIndex, field, value) {
            if (raceIndex < 0 || raceIndex >= shortCourseSessionRaces.length || entryIndex < 0 || entryIndex >= shortCourseSessionRaces[raceIndex].entries.length) {
                console.error("Invalid indices for updateShortCourseEntry"); return;
            }
            const entry = shortCourseSessionRaces[raceIndex].entries[entryIndex];
            entry[field] = value;
            if (field === 'status') {
                const row = shortCourseRacesContainer.querySelector(`div[data-race-index="${raceIndex}"] tr[data-entry-index="${entryIndex}"]`);
                const timeInput = row?.querySelector('.sc-time-input');
                if (timeInput) {
                    timeInput.disabled = (value !== 'finished');
                    if (value !== 'finished') {
                        timeInput.value = '';
                        entry.elapsedTime = '';
                    }
                }
            }
             if (field === 'elapsedTime' && entry.status === 'finished' && value && !isValidTimeFormat(value)) {
                 console.warn("Invalid time format entered:", value);
             }
        }

        function updateCreateRaceButton() {
            if (createShortCourseRaceBtn) {
                const nextRaceNum = shortCourseSessionRaces.length + 1;
                createShortCourseRaceBtn.textContent = `Create Race ${nextRaceNum}`;
            }
        }

        function clearShortCourseSessionData() {
            shortCourseSessionRaces = [];
            if (shortCourseRacesContainer) shortCourseRacesContainer.innerHTML = '<h3>Created Races (This Session)</h3><p>No races created yet in this session.</p>';
            updateCreateRaceButton();
        }
         if (clearShortCourseSessionBtn) clearShortCourseSessionBtn.addEventListener('click', () => {
            if (shortCourseSessionRaces.length === 0) {
                 alert("There are no created races in this session to clear.");
                 return;
            }
            if (confirm(`Are you sure you want to clear the ${shortCourseSessionRaces.length} ${pluralize(shortCourseSessionRaces.length, 'race')} created in this session? This cannot be undone.`)) {
                clearShortCourseSessionData();
            }
         });


        // --- Results Calculation (MODIFIED for Short Course) ---
        if(calculateResultsBtn) calculateResultsBtn.addEventListener('click', async () => { // Made async
            if (currentSeries?.isShortCourse) {
                 // ... (short course logic remains unchanged)
                 if (shortCourseSessionRaces.length === 0) {
                    alert("No races have been created in this session. Use the 'Create Race N' button first.");
                    return;
                 }
                 if (!currentSeries) {
                     alert("Error: No series selected."); return;
                 }
                 console.log(`Calculating and saving ${shortCourseSessionRaces.length} short course races for series: ${currentSeries.name}`);
                 try {
                     let racesAddedCount = 0;
                     const seriesToUpdate = series.find(s => s.id === currentSeries.id);
                     if (!seriesToUpdate) throw new Error("Could not find the series in the main data array.");

                     const maxExistingRaceNum = seriesToUpdate.races.reduce((max, race) => Math.max(max, race.raceNumber), 0);
                     let nextRaceNum = maxExistingRaceNum + 1;

                     for (const sessionRaceData of shortCourseSessionRaces) {
                         const invalidTimeEntry = sessionRaceData.entries.find(e => e.status === 'finished' && !isValidTimeFormat(e.elapsedTime));
                         if (invalidTimeEntry) {
                             throw new Error(`Invalid time format for ${invalidTimeEntry.sailNumber} in Race ${sessionRaceData.raceNumber}. Please correct before calculating.`);
                         }
                         const calculatedResults = calculateSingleRaceResults(sessionRaceData.entries, seriesToUpdate);
                         const raceToSave = {
                             raceNumber: nextRaceNum,
                             date: new Date().toISOString().split('T')[0],
                             entries: JSON.parse(JSON.stringify(sessionRaceData.entries)),
                             results: calculatedResults
                         };
                         seriesToUpdate.races.push(raceToSave);
                         racesAddedCount++;
                         nextRaceNum++;
                     }
                     seriesToUpdate.numberOfRaces = seriesToUpdate.races.length;
                     seriesToUpdate.races.sort((a, b) => a.raceNumber - b.raceNumber);

                     await saveDataToGoogleSheet(); // SAVE TO GOOGLE SHEET

                     const seriesIdJustUpdated = seriesToUpdate.id;
                     clearShortCourseSessionData();
                     refreshSeriesDropdowns();
                     refreshSeriesList();
                     alert(`${racesAddedCount} ${pluralize(racesAddedCount, 'race')} added and saved to series "${seriesToUpdate.name}".`);
                     setActiveTab(raceViewTab);
                     if(viewAllSeries) viewAllSeries.value = seriesIdJustUpdated;
                     displayRaceViewer();
                 } catch (error) {
                     console.error("Error calculating or saving short course races:", error);
                     alert("Error: " + error.message);
                 }
            } else { // Standard Race
                if (entries.length === 0) { alert('Add at least one boat entry first.'); return; }
                if (!currentSeries || !currentRace) { alert("Select a series and race number first."); return; }

                const raceNumberFromEntryTab = currentRace; // Store the race number from the entry tab
                const newlyCalculatedResults = calculateSingleRaceResults(entries, currentSeries, raceNumberFromEntryTab);

                setActiveTab(resultsTab);
                if (resultsSeries) resultsSeries.value = currentSeries.id;

                // Populate the resultsRace dropdown. This might trigger its 'change' event listener
                // if its internal default selection logic changes the dropdown's value.
                // That listener would call loadRaceResults(), potentially loading saved data.
                updateResultsRaceDropdown(false);

                // Now, explicitly set the resultsRace dropdown to the race we just calculated for.
                // This will also trigger its 'change' event listener if the value changes.
                // The listener will set global `currentRace` and call `loadRaceResults()`.
                if (resultsRace) {
                    const raceOptionValueStr = String(raceNumberFromEntryTab);
                    if (Array.from(resultsRace.options).some(opt => opt.value === raceOptionValueStr)) {
                        // Set the value. If it's different, it triggers 'change'.
                        // If it's the same, 'change' might not fire, but the value is correct.
                        resultsRace.value = raceOptionValueStr;
                    } else if (resultsRace.options.length > 0) {
                        // Fallback if the specific race option doesn't exist (should not happen for valid race numbers)
                        resultsRace.selectedIndex = 0;
                    }
                    // At this point, resultsRace.value is set, and its 'change' listener has likely run,
                    // setting global currentRace and potentially loading saved results into global `results`.
                }

                // IMPORTANT: Override global `results` with our newly calculated ones,
                // and ensure global `currentRace` reflects the race these results are for.
                results = newlyCalculatedResults;
                currentRace = raceNumberFromEntryTab; // Re-affirm global currentRace

                renderRaceResults(); // Now render our newly calculated results for the correct race
                disableDirectEditMode();

                if (resultRaceInfo) {
                    const infoPanel = resultRaceInfo.querySelector('.race-info-panel');
                    const infoHtml = infoPanel ? infoPanel.outerHTML : '';
                    resultRaceInfo.innerHTML = infoHtml + `<p style="color: orange; font-weight: bold; margin-top: 10px;">Results have been calculated. Please review carefully. If everything is correct, click 'Save These Results to Series' to finalize and save them.</p>`;
                }
            }
        });

        function calculateSingleRaceResults(raceEntries, targetSeries, raceNumberForOOD = null) {
             if (!raceEntries || raceEntries.length === 0) return [];
             let calculated = JSON.parse(JSON.stringify(raceEntries));
             calculated.forEach(result => {
                 result.elapsedTime = result.elapsedTime || ''; // Ensure elapsedTime is a string
                 if (result.status === 'finished') {
                     if (typeof result.elapsedTime === 'string' && result.elapsedTime.length > 0 && isValidTimeFormat(result.elapsedTime)) {
                         const elapsedSeconds = timeToSeconds(result.elapsedTime);
                         if (result.yardstick && result.yardstick > 0) {
                             const correctedSeconds = elapsedSeconds * 100 / result.yardstick;
                             result.correctedSeconds = correctedSeconds;
                             result.correctedTime = secondsToTime(correctedSeconds);
                         } else {
                             result.correctedSeconds = Infinity; result.correctedTime = 'Error: YS';
                         }
                     } else {
                          result.correctedSeconds = Infinity; result.correctedTime = 'Error: Time';
                     }
                 } else {
                     result.correctedSeconds = null; result.correctedTime = null;
                 }
             });
             calculated.sort((a, b) => {
                 const statusOrder = { finished: 0, OOD: 1, DNF: 2, DSQ: 3, OCS: 4, DNS: 5 };
                 const statusA = statusOrder[a.status] ?? 99;
                 const statusB = statusOrder[b.status] ?? 99;
                 if (statusA !== statusB) return statusA - statusB;
                 if (a.status === 'finished') {
                     const correctedA = a.correctedSeconds ?? Infinity;
                     const correctedB = b.correctedSeconds ?? Infinity;
                     return correctedA - correctedB;
                 }
                 return 0;
             });
             let position = 1;
             let nonFinishersScore;
             const dncRule = targetSeries?.dncScoringRule || 'raceEntries';
             if (dncRule === 'raceEntries') {
                 nonFinishersScore = calculated.length + 1;
             } else {
                 const allCompetitorsInSeries = new Set();
                 targetSeries?.races?.forEach(r => {
                     if (r.results) r.results.forEach(res => allCompetitorsInSeries.add(res.sailNumber));
                     else if (r.entries) r.entries.forEach(ent => allCompetitorsInSeries.add(ent.sailNumber));
                 });
                 raceEntries.forEach(e => allCompetitorsInSeries.add(e.sailNumber));
                 nonFinishersScore = allCompetitorsInSeries.size + 1;
             }
             calculated.forEach((result, i) => {
                 if (result.status === 'finished') {
                     if (result.correctedSeconds === null || result.correctedSeconds === Infinity) {
                         result.position = 'Error';
                     } else if (i > 0 && calculated[i-1].status === 'finished' &&
                         typeof result.correctedSeconds === 'number' && typeof calculated[i-1].correctedSeconds === 'number' &&
                         result.correctedSeconds === calculated[i-1].correctedSeconds) {
                          result.position = calculated[i-1].position;
                     } else {
                         result.position = position;
                     }
                      if (result.position !== 'Error' && (i === 0 || result.position !== calculated[i-1].position || calculated[i-1].position === 'Error')) {
                           position++;
                      }
                 } else {
                     result.position = result.status.toUpperCase();
                 }
             });
             calculated.forEach(result => {
                 if (result.status === 'finished') {
                    if (typeof result.position === 'number') {
                        result.points = result.position;
                    } else {
                        result.points = nonFinishersScore;
                    }
                 } else if (['DNF', 'DNS', 'OCS', 'DSQ'].includes(result.status)) {
                     result.points = nonFinishersScore;
                 } else if (result.status === 'OOD') {
                     result.points = calculateOODPoints(result.sailNumber, calculated, targetSeries, raceNumberForOOD);
                 } else {
                     result.points = null;
                 }
             });
             return calculated;
         }

        function calculateOODPoints(sailNo, currentRaceCalculatedResults, targetSeries, oodRaceNumber) {
            const finishersInCurrentRace = currentRaceCalculatedResults.filter(r => r.status === 'finished' && typeof r.points === 'number');
            let fallbackPoints = 0;
            if (finishersInCurrentRace.length > 0) {
                const avgFinisherPoints = finishersInCurrentRace.reduce((sum, r) => sum + r.points, 0) / finishersInCurrentRace.length;
                fallbackPoints = Math.round(avgFinisherPoints * 10) / 10;
            } else {
                fallbackPoints = 0;
            }
            if (!targetSeries || oodRaceNumber === null) {
                return fallbackPoints;
            }
            let racePoints = [];
            let racesSailedCount = 0;
            targetSeries.races.forEach(race => {
                 if (race.raceNumber !== oodRaceNumber && race.results && race.results.length > 0) {
                     const boatResult = race.results.find(r => r.sailNumber === sailNo);
                     if (boatResult && typeof boatResult.points === 'number' && boatResult.status === 'finished') {
                         racePoints.push(boatResult.points);
                         racesSailedCount++;
                     }
                 }
             });
            if (racesSailedCount > 0) {
                const avgPoints = racePoints.reduce((sum, pts) => sum + pts, 0) / racesSailedCount;
                return Math.round(avgPoints * 10) / 10;
            } else {
                 return fallbackPoints;
             }
         }


        // --- Race Results Tab Functions ---
        function renderRaceResults() {
            if (!resultsBody || !resultRaceInfo) return;
            resultsBody.innerHTML = '';
            const seriesName = currentSeries ? currentSeries.name : (resultsSeries?.options[resultsSeries?.selectedIndex]?.text || 'N/A');
            const raceNumber = currentRace || resultsRace?.value || 'N/A';
            const raceData = currentSeries?.races.find(r => r.raceNumber === parseInt(raceNumber));
            const date = raceData?.date ? new Date(raceData.date + 'T00:00:00').toLocaleDateString() : 'Not set';

            let statusMessage = ''; const statusPara = resultRaceInfo.querySelector('p[style*="color: orange"]'); if (statusPara) statusMessage = statusPara.outerHTML;
            resultRaceInfo.innerHTML = `<div class="race-info-panel"><h3>Race Information</h3><p><strong>Series:</strong> ${seriesName}</p><p><strong>Race Number:</strong> ${raceNumber}</p><p><strong>Entries Shown:</strong> ${results?.length || 0}</p></div>` + statusMessage;

            if (!results || results.length === 0) {
                 const existingInfo = resultRaceInfo.innerHTML;
                 resultRaceInfo.innerHTML = existingInfo + '<p>No results calculated or loaded for this race.</p>';
                 const row = resultsBody.insertRow(); const cell = row.insertCell(); cell.colSpan = 10;
                 cell.textContent = 'No results to display.'; cell.style.textAlign = 'center'; cell.style.fontStyle = 'italic'; cell.style.color = '#666'; return;
            }
            results.forEach((result, index) => {
                const row = resultsBody.insertRow(); row.dataset.index = index;
                if (directEditMode) row.classList.add('result-highlight');
                row.innerHTML = `
                    <td>${result.position ?? '-'}</td><td>${result.sailNumber}</td><td>${result.boatClass}</td><td>${result.skipper}</td>
                    <td>${result.yardstick}</td><td>${result.status.toUpperCase()}</td><td>${result.elapsedTime || '-'}</td><td>${result.correctedTime || '-'}</td>
                    <td>${result.points ?? '-'}</td><td class="actions">
                        <button class="btn-edit edit-result-btn ${directEditMode ? '' : 'hidden'}" onclick="showEditResultDialog(${index})">Edit</button>
                    </td>`;
            });
        }

        if(saveResultsTabBtn) saveResultsTabBtn.addEventListener('click', async () => { // Made async
            const seriesId = resultsSeries?.value; const raceNumStr = resultsRace?.value;
            if (!seriesId || !raceNumStr) { alert("Select Series and Race first."); return; }
            const raceNum = parseInt(raceNumStr);
            if (!results) { alert("No results data available to save."); return; }
            if (results.length === 0 && !confirm(`No results displayed for Race ${raceNum}. Save as having no results? This clears previous results.`)) { return; }
            const targetSeries = series.find(s => s.id === parseInt(seriesId)); if (!targetSeries) { alert("Error: Series not found."); return; }
            if (targetSeries.isShortCourse) {
                alert("Saving for short courses is done via the 'Calculate Race Results & View' button on the Race Entry tab after creating races.");
                return;
            }
            const raceIndex = targetSeries.races.findIndex(race => race.raceNumber === raceNum); if (raceIndex === -1) { alert(`Error: Race ${raceNum} not found in series.`); return; }
            const existingSavedResults = targetSeries.races[raceIndex].results;
            if (existingSavedResults && existingSavedResults.length > 0 && results.length > 0 && !confirm(`Race ${raceNum} already has saved results. Overwrite?`)) { return; }
            const resultsToSave = JSON.parse(JSON.stringify(results));
            const entriesToSave = resultsToSave.map(res => ({ sailNumber: res.sailNumber, boatClass: res.boatClass, skipper: res.skipper, yardstick: res.yardstick, status: res.status, elapsedTime: res.elapsedTime || '' }));
            let dateToSave = targetSeries.races[raceIndex].date || new Date().toISOString().split('T')[0];

            try {
                targetSeries.races[raceIndex].date = dateToSave;
                targetSeries.races[raceIndex].entries = entriesToSave;
                targetSeries.races[raceIndex].results = resultsToSave;

                await saveDataToGoogleSheet(); // SAVE TO GOOGLE SHEET

                editMode = false; editModeWarning?.classList.add('hidden');
                disableDirectEditMode();
                alert(`Race ${raceNum} results saved successfully for series "${targetSeries.name}".`);
                refreshSeriesDropdowns();
                if (resultsSeries) resultsSeries.value = seriesId;
                updateResultsRaceDropdown(false); if (resultsRace) resultsRace.value = raceNumStr;
                loadRaceResults();
                if (seriesResultsTab && seriesResultsTab.classList.contains('active-tab') && viewSeries?.value === seriesId) calculateSeriesResults();
                if (raceViewTab && raceViewTab.classList.contains('active-tab') && viewAllSeries?.value === seriesId) {
                    displayRaceViewer();
                    const raceButton = raceSelector?.querySelector(`.race-button[data-race-number="${raceNum}"]`);
                    if (raceButton) { document.querySelectorAll('.race-button.active').forEach(b => b.classList.remove('active')); raceButton.classList.add('active'); displayRaceResultsView(targetSeries, raceNum); }
                }
            } catch (error) { console.error("Error saving race results:", error); alert("Error saving race results."); }
        });

        if(editRaceEntriesBtn) editRaceEntriesBtn.addEventListener('click', () => {
            const seriesId = resultsSeries?.value; const raceNumStr = resultsRace?.value; if (!seriesId || !raceNumStr) { alert('Select Series and Race first.'); return; }
            const raceNum = parseInt(raceNumStr); const seriesForEdit = series.find(s => s.id === parseInt(seriesId)); if (!seriesForEdit) { alert("Series not found."); return; }
            if (seriesForEdit.isShortCourse) {
                 alert("Editing entries for saved Short Course races is not directly supported via this button. Manage boats in the 'Race Entries' on the Race Entry tab before creating races.");
                 return;
            }
            const raceForEdit = seriesForEdit.races.find(r => r.raceNumber === raceNum); if (!raceForEdit) { alert("Race not found."); return; }
            entries = (raceForEdit.entries && raceForEdit.entries.length > 0)
                ? JSON.parse(JSON.stringify(raceForEdit.entries))
                : (raceForEdit.results && raceForEdit.results.length > 0)
                    ? raceForEdit.results.map(res => ({ sailNumber: res.sailNumber, boatClass: res.boatClass, skipper: res.skipper, yardstick: res.yardstick, status: res.status, elapsedTime: res.elapsedTime || '' }))
                    : [];
            setActiveTab(raceTab);
            switchToStandardRaceUI();
            if(selectSeries) selectSeries.value = seriesId; updateRaceDropdown(); if(selectRace) selectRace.value = raceNumStr;
            renderEntriesTable(); editMode = true;
            if(editModeWarning) { editModeWarning.textContent = `Editing Mode: Loaded saved entries for Race ${raceNum}. Modify entries, then use 'Calculate Race Results & View' and 'Save These Results' on the Results tab.`; editModeWarning.classList.remove('hidden'); }
            disableDirectEditMode(); clearEntryForm();
        });

        if(editResultsDirectlyBtn) editResultsDirectlyBtn.addEventListener('click', () => { if (!results || results.length === 0) { alert("No results loaded to edit directly."); return; } if (directEditMode) disableDirectEditMode(); else enableDirectEditMode(); });
        function enableDirectEditMode() {
             directEditMode = true;
             if(directEditWarning) { directEditWarning.innerHTML = `<strong>Direct Edit Mode Active:</strong> Manually edit positions, points, status, or time below. Use 'Update Displayed Result' then 'Save These Results to Series'. Recalculating will revert direct edits.`; directEditWarning.classList.remove('hidden'); }
             if(editResultsDirectlyBtn) { editResultsDirectlyBtn.textContent = 'Cancel Direct Edit'; editResultsDirectlyBtn.classList.add('btn-danger'); editResultsDirectlyBtn.classList.remove('btn-warning'); }
             renderRaceResults(); if(editResultForm) editResultForm.classList.add('hidden');
         }
        function disableDirectEditMode() {
             directEditMode = false;
             if(directEditWarning) directEditWarning.classList.add('hidden');
             if(editResultsDirectlyBtn) { editResultsDirectlyBtn.textContent = 'Direct Edit'; editResultsDirectlyBtn.classList.remove('btn-danger'); editResultsDirectlyBtn.classList.add('btn-warning'); }
             if(editResultForm) editResultForm.classList.add('hidden');
             renderRaceResults(); resultsBody?.querySelectorAll('.edit-result-btn').forEach(btn => btn.classList.add('hidden')); resultsBody?.querySelectorAll('tr.result-highlight').forEach(row => row.classList.remove('result-highlight'));
         }
        function showEditResultDialog(index) {
            if (!directEditMode || index < 0 || index >= results.length) return;
            const result = results[index]; resultBeingEdited = JSON.parse(JSON.stringify(result));
            if(editResultLabel) editResultLabel.textContent = `${result.sailNumber} - ${result.skipper} (${result.boatClass})`;
            if(editStatusDirect) editStatusDirect.value = result.status;
            if(editElapsedTimeDirect) editElapsedTimeDirect.value = result.elapsedTime || '';
            if(editPositionDirect) editPositionDirect.value = result.position ?? '';
            if(editPointsDirect) editPointsDirect.value = result.points ?? '';
            if(editResultIndex) editResultIndex.value = index;
            if(editTimeInputsDirect) editTimeInputsDirect.style.display = (editStatusDirect?.value === 'finished') ? 'block' : 'none';
            if(editResultForm) { editResultForm.classList.remove('hidden'); editResultForm.scrollIntoView({ behavior: 'smooth', block: 'center' }); }
        }
        if(editStatusDirect) editStatusDirect.addEventListener('change', () => { if(editTimeInputsDirect) editTimeInputsDirect.style.display = (editStatusDirect.value === 'finished') ? 'block' : 'none'; if (editStatusDirect.value !== 'finished' && editElapsedTimeDirect) editElapsedTimeDirect.value = ''; });
        if(saveEditResult) saveEditResult.addEventListener('click', () => {
             const index = parseInt(editResultIndex?.value); if (isNaN(index) || index < 0 || index >= results.length) { alert('Error saving edit: Invalid index.'); return; }
             const status = editStatusDirect?.value; const elapsed = editElapsedTimeDirect?.value.trim(); let positionInput = editPositionDirect?.value.trim(); const pointsInput = editPointsDirect?.value.trim();
             if(!status) { alert("Status is required."); return; } if(!positionInput) { alert("Position (or status code) is required."); return;} if(!pointsInput) { alert("Points are required."); return;}
             const points = parseFloat(pointsInput); if (isNaN(points)) { alert('Valid number for Points required.'); return; }
             if (status === 'finished' && !elapsed) { alert('Elapsed time (hh:mm:ss) required for Finished status in direct edit.'); return; } if (status === 'finished' && elapsed && !isValidTimeFormat(elapsed)) { alert('Valid elapsed time (hh:mm:ss) required, or change status.'); return; }
             let position; const positionNum = parseInt(positionInput);
             if (!isNaN(positionNum) && String(positionNum) === positionInput) { position = positionNum; }
             else { const allowedCodes = ['DNF', 'DNS', 'OCS', 'DSQ', 'OOD']; if (allowedCodes.includes(positionInput.toUpperCase())) { position = positionInput.toUpperCase(); } else { if (status !== 'finished') position = status.toUpperCase(); else { alert(`Invalid Position value "${positionInput}" for Finished status. Enter a number.`); return; } } }
             results[index].status = status; results[index].elapsedTime = (status === 'finished') ? elapsed : ''; results[index].position = position; results[index].points = points;
             if (status === 'finished' && elapsed) { const tempElapsedSeconds = timeToSeconds(elapsed); const tempCorrectedSeconds = tempElapsedSeconds * 100 / results[index].yardstick; results[index].correctedTime = secondsToTime(tempCorrectedSeconds); results[index].correctedSeconds = tempCorrectedSeconds; }
             else { results[index].correctedTime = null; results[index].correctedSeconds = null; }
             if(editResultForm) editResultForm.classList.add('hidden'); renderRaceResults();
             if(directEditWarning) { directEditWarning.innerHTML = `<strong>Direct Edit Mode Active:</strong> Result display updated. Click 'Save These Results' to make changes permanent. Recalculating will revert direct edits.`; directEditWarning.classList.remove('hidden'); }
             console.log(`Result for index ${index} display updated (direct edit).`);
         });
        if(cancelEditResult) cancelEditResult.addEventListener('click', () => { if(editResultForm) editResultForm.classList.add('hidden'); resultBeingEdited = null; });


        // --- Series Management (MODIFIED for Short Course) ---
        if (seriesShortCourseCheck) seriesShortCourseCheck.addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            if (standardSeriesOptions) standardSeriesOptions.classList.toggle('hidden', isChecked);
        });

        if(createSeriesBtn) createSeriesBtn.addEventListener('click', () => {
            if(seriesName) seriesName.value = '';
            if(seriesShortCourseCheck) seriesShortCourseCheck.checked = false;
            if(standardSeriesOptions) standardSeriesOptions.classList.remove('hidden');
            if(numberOfRaces) numberOfRaces.value = '8';
            if(racesPerDiscardInput) racesPerDiscardInput.value = '4';
            if(editSeriesId) editSeriesId.value = '';
            const defaultDncRadio = document.getElementById('dnc-rule-race');
            if(defaultDncRadio) defaultDncRadio.checked = true;
            if(createSeriesForm) createSeriesForm.classList.remove('hidden');
        });

        if(saveSeriesBtn) saveSeriesBtn.addEventListener('click', async () => { // Made async
            const name = seriesName?.value.trim();
            const isShortCourse = seriesShortCourseCheck?.checked || false;
            let races = parseInt(numberOfRaces?.value);
            let discardThreshold = parseInt(racesPerDiscardInput?.value);
            const editId = editSeriesId?.value;
            const dncRuleInput = document.querySelector('input[name="dnc-scoring-rule"]:checked');
            const dncScoringRule = dncRuleInput ? dncRuleInput.value : 'raceEntries';

            if (!name) { alert('Series Name required.'); return; }
            if (isShortCourse) {
                discardThreshold = 0;
            } else {
                if (isNaN(races) || isNaN(discardThreshold)) { alert('Number of Races and Races Per Discard required for standard series.'); return; }
                if (races < 1 || races > 50) { alert('Number of races must be 1-50.'); return; }
                if (discardThreshold < 0 || discardThreshold > 20 ) { alert(`'Races Per Discard' must be between 0 and 20. (0 means no discards).`); return; }
            }

            if (editId) {
                const seriesIndex = series.findIndex(s => s.id === parseInt(editId));
                if (seriesIndex !== -1) {
                    const existingSeries = series[seriesIndex];
                    existingSeries.name = name;
                    existingSeries.isShortCourse = isShortCourse;
                    existingSeries.dncScoringRule = dncScoringRule;
                    existingSeries.discardThreshold = discardThreshold;
                    if (isShortCourse) {
                         existingSeries.numberOfRaces = existingSeries.races.length;
                    } else {
                        existingSeries.numberOfRaces = races;
                         if (races > existingSeries.races.length) {
                            const start = existingSeries.races.length + 1;
                            for (let i = start; i <= races; i++) { existingSeries.races.push({ raceNumber: i, date: null, entries: [], results: [] }); }
                        } else if (races < existingSeries.races.length) {
                             const racesToRemove = existingSeries.races.slice(races);
                             const hasResultsInRemoved = racesToRemove.some(r => r.results && r.results.length > 0);
                             if (hasResultsInRemoved && !confirm(`Reducing races removes races ${races + 1}-${existingSeries.races.length} and their results. Continue?`)) {
                                 if (numberOfRaces) numberOfRaces.value = existingSeries.races.length;
                                 existingSeries.numberOfRaces = existingSeries.races.length;
                                 return;
                             }
                             existingSeries.races = existingSeries.races.slice(0, races);
                         }
                    }
                    alert(`Series "${name}" updated.`);
                } else {
                     alert("Error finding series to update."); return;
                }
            } else {
                 const newSeries = {
                     id: Date.now(), name, isShortCourse,
                     numberOfRaces: isShortCourse ? 0 : races,
                     discardThreshold, dncScoringRule, races: []
                 };
                 if (!isShortCourse) {
                     for (let i = 1; i <= races; i++) { newSeries.races.push({ raceNumber: i, date: null, entries: [], results: [] }); }
                 }
                 series.push(newSeries);
                 alert(`Series "${name}" (${isShortCourse ? 'Short Course' : 'Standard'}) created.`);
            }
            await saveDataToGoogleSheet(); // SAVE TO GOOGLE SHEET
            refreshSeriesList();
            refreshSeriesDropdowns();
            if(createSeriesForm) createSeriesForm.classList.add('hidden');
        });

        if(cancelSeriesBtn) cancelSeriesBtn.addEventListener('click', () => { if(createSeriesForm) createSeriesForm.classList.add('hidden'); });

        function refreshSeriesList() {
            if (!seriesList) return;
            seriesList.innerHTML = ''; if (series.length === 0) { seriesList.innerHTML = '<p>No series defined. Create one first.</p>'; return; }
            series.forEach(s => {
                const seriesCard = document.createElement('div'); seriesCard.classList.add('race-card');
                const racesWithResults = s.races.filter(race => race.results && race.results.length > 0).length;
                let dncRuleText = '';
                const rule = s.dncScoringRule || 'raceEntries';
                if (rule === 'raceEntries') dncRuleText = 'Race Entries + 1'; else dncRuleText = 'Series Competitors + 1';
                let detailsHTML = '';
                const seriesType = s.isShortCourse ? 'Short Course' : 'Standard';
                if (s.isShortCourse) {
                     detailsHTML = `<p><strong>Type:</strong> ${seriesType}</p>
                                   <p><strong>Races Saved:</strong> ${s.races.length}</p>`;
                } else {
                    const discardThreshold = s.discardThreshold ?? 0;
                    const discardRuleText = discardThreshold > 0 ? `1 discard per ${discardThreshold} completed races` : 'No discards';
                     detailsHTML = `<p><strong>Type:</strong> ${seriesType}</p>
                                    <p><strong>Races Planned:</strong> ${s.numberOfRaces} (${racesWithResults} completed)</p>
                                    <p><strong>Discard Rule:</strong> ${discardRuleText}</p>`;
                }
                seriesCard.innerHTML = `
                    <div class="race-info"><h3>${s.name}</h3></div>
                    ${detailsHTML}
                    <p><strong>DNC Scoring Rule:</strong> ${dncRuleText}</p>
                    <div class="race-actions">
                        <button class="btn-edit" onclick="editSeries(${s.id})">Edit Details</button>
                        <button class="btn-danger" onclick="deleteSeries(${s.id})">Delete Series</button>
                    </div>`;
                seriesList.appendChild(seriesCard);
            });
        }

        function editSeries(id) {
            const s = series.find(s => s.id === id); if (!s) return;
            if(seriesName) seriesName.value = s.name;
            if(seriesShortCourseCheck) seriesShortCourseCheck.checked = s.isShortCourse || false;
            if(standardSeriesOptions) standardSeriesOptions.classList.toggle('hidden', s.isShortCourse);
            if (!s.isShortCourse) {
                 if(numberOfRaces) numberOfRaces.value = s.numberOfRaces;
                 if(racesPerDiscardInput) racesPerDiscardInput.value = s.discardThreshold ?? 0;
            } else {
                 if(numberOfRaces) numberOfRaces.value = '8';
                 if(racesPerDiscardInput) racesPerDiscardInput.value = '4';
            }
            if(editSeriesId) editSeriesId.value = s.id;
            const currentDncRule = s.dncScoringRule || 'raceEntries';
            const dncRadioToSelect = document.getElementById(`dnc-rule-${currentDncRule === 'seriesCompetitors' ? 'series' : 'race'}`);
            if (dncRadioToSelect) dncRadioToSelect.checked = true;
            else { const defaultDncRadio = document.getElementById('dnc-rule-race'); if(defaultDncRadio) defaultDncRadio.checked = true; }
            if(createSeriesForm) {
                createSeriesForm.classList.remove('hidden');
                createSeriesForm.scrollIntoView({ behavior: 'smooth' });
            }
        }

        async function deleteSeries(id) { // Made async
            const seriesIndex = series.findIndex(s => s.id === id); if (seriesIndex === -1) return; const s = series[seriesIndex];
            if (confirm(`DELETE Series "${s.name}" and ALL its data permanently? Cannot be undone.`)) {
                series.splice(seriesIndex, 1);
                await saveDataToGoogleSheet(); // SAVE TO GOOGLE SHEET
                refreshSeriesList(); refreshSeriesDropdowns();
                if (selectSeries?.value == id) selectSeries.value = "";
                if (resultsSeries?.value == id) { resultsSeries.value = ""; loadRaceResults(); }
                if (viewSeries?.value == id) { viewSeries.value = ""; calculateSeriesResults(); }
                if (viewAllSeries?.value == id) { viewAllSeries.value = ""; displayRaceViewer();}
                if (currentSeries && currentSeries.id === id) {
                    currentSeries = null; currentRace = null; entries = []; results = []; shortCourseSessionRaces = [];
                    if(raceTab?.classList.contains('active-tab')) updateRaceEntryUI();
                    if(resultsTab?.classList.contains('active-tab')) renderRaceResults();
                }
                alert(`Series "${s.name}" deleted.`);
            }
        }

        // --- Dropdown and State Management (MODIFIED for Short Course) ---
        function refreshSeriesDropdowns() {
             const dropdowns = [selectSeries, resultsSeries, viewSeries, viewAllSeries];
             dropdowns.forEach((dropdown) => {
                 if (!dropdown) return; const selectedVal = dropdown.value; dropdown.innerHTML = '<option value="">Select Series</option>';
                 series.sort((a, b) => a.name.localeCompare(b.name));
                 series.forEach(s => { const option = document.createElement('option'); option.value = s.id; option.textContent = s.name + (s.isShortCourse ? ' (Short Course)' : ''); dropdown.appendChild(option); });
                 if (selectedVal && series.some(s => s.id == selectedVal)) dropdown.value = selectedVal; else dropdown.value = "";
             });
             setTimeout(() => {
                updateRaceEntryUI();
                if (resultsSeries?.value) updateResultsRaceDropdown(); else if (resultsRace) { resultsRace.innerHTML = ''; loadRaceResults(); }
             }, 0);
         }

         function updateRaceEntryUI() {
             const seriesId = selectSeries?.value;
             if (!seriesId) {
                 currentSeries = null; currentRace = null;
                 switchToStandardRaceUI(); selectRace.innerHTML = ''; entries = [];
                 renderEntriesTable(); clearEntryForm(); clearShortCourseSessionData();
                 return;
             }
             currentSeries = series.find(s => s.id === parseInt(seriesId));
             if (!currentSeries) {
                 console.error("Selected series not found!");
                 currentSeries = null; currentRace = null;
                 switchToStandardRaceUI(); selectRace.innerHTML = ''; entries = [];
                 renderEntriesTable(); clearEntryForm(); clearShortCourseSessionData();
                 return;
             }
             entries = []; clearShortCourseSessionData();
             editMode = false; editModeWarning?.classList.add('hidden');
             clearEntryForm();
             if (currentSeries.isShortCourse) {
                 switchToShortCourseUI();
                 renderShortCoursePoolTable();
             } else {
                 switchToStandardRaceUI();
                 updateRaceDropdown();
             }
         }

         function switchToStandardRaceUI() {
             if (raceSelectorWrapper) raceSelectorWrapper.classList.remove('hidden');
             if (standardEntryFields) standardEntryFields.classList.remove('hidden');
             if (standardEntriesDisplay) standardEntriesDisplay.classList.remove('hidden');
             if (shortCourseStagingDisplay) shortCourseStagingDisplay.classList.add('hidden');
             if (shortCourseRacesContainer) shortCourseRacesContainer.classList.add('hidden');
             if (clearShortCourseSessionBtn) clearShortCourseSessionBtn.classList.add('hidden');
             if (entryFormTitle) entryFormTitle.textContent = "Add/Edit Boat Entry";
             if (addBoatBtn) addBoatBtn.textContent = "Add Boat to Race";
             if (clearAllBtn) clearAllBtn.textContent = "Clear All Current Entries";
             currentRace = (selectRace && selectRace.value) ? parseInt(selectRace.value) : null;
             handleStatusChange();
         }

         function switchToShortCourseUI() {
             if (raceSelectorWrapper) raceSelectorWrapper.classList.add('hidden');
             if (standardEntryFields) standardEntryFields.classList.add('hidden');
             if (standardEntriesDisplay) standardEntriesDisplay.classList.add('hidden');
             if (shortCourseStagingDisplay) shortCourseStagingDisplay.classList.remove('hidden');
             if (shortCourseRacesContainer) shortCourseRacesContainer.classList.remove('hidden');
             if (clearShortCourseSessionBtn) clearShortCourseSessionBtn.classList.remove('hidden');
             if (entryFormTitle) entryFormTitle.textContent = "Add/Edit Boat for Pool";
             if (addBoatBtn) addBoatBtn.textContent = "Add Boat to Entries";
             if (clearAllBtn) clearAllBtn.textContent = "Clear Current Entries";
             if (selectRace) selectRace.innerHTML = '';
             currentRace = null;
             renderShortCourseSessionRaces();
             updateCreateRaceButton();
         }

        function updateRaceDropdown() {
            if (!selectRace || !currentSeries || currentSeries.isShortCourse) {
                 if (selectRace) selectRace.innerHTML = '';
                 updateRaceInfoAndEntries();
                 return;
            }
            const selectedRaceVal = selectRace.value;
            selectRace.innerHTML = '';
            populateRaceOptions(selectRace, currentSeries, true);
            if (selectedRaceVal && currentSeries.races.some(r => r.raceNumber == selectedRaceVal)) {
                selectRace.value = selectedRaceVal;
            } else if (currentSeries.races.length > 0 && currentSeries.races[0].raceNumber) {
                 const firstRaceNum = currentSeries.races.sort((a,b) => a.raceNumber - b.raceNumber)[0].raceNumber;
                 selectRace.value = String(firstRaceNum);
            } else {
                 selectRace.innerHTML = '<option value="">No races</option>';
                 selectRace.disabled = true;
            }
            updateRaceInfoAndEntries();
        }

        function updateResultsRaceDropdown(loadResultsAfterUpdate = true) {
            if (!resultsRace || !resultsSeries) return; const selectedRaceVal = resultsRace.value; resultsRace.innerHTML = '';
            const seriesId = resultsSeries.value; const selectedSeriesForDropdown = series.find(s => s.id === parseInt(seriesId));
            if (!selectedSeriesForDropdown) { currentSeries = null; currentRace = null; if (loadResultsAfterUpdate) { results = []; renderRaceResults(); } return; }
            populateRaceOptions(resultsRace, selectedSeriesForDropdown, true);
            let defaultRaceVal = null;
            if (selectedRaceVal && selectedSeriesForDropdown.races.some(r => r.raceNumber == selectedRaceVal)) { defaultRaceVal = selectedRaceVal; }
            else if (selectedSeriesForDropdown.races.length > 0) { let lastRaceWithResults = -1; for(let i = selectedSeriesForDropdown.races.length - 1; i >= 0; i--){ if(selectedSeriesForDropdown.races[i].results && selectedSeriesForDropdown.races[i].results.length > 0){ lastRaceWithResults = selectedSeriesForDropdown.races[i].raceNumber; break; } } defaultRaceVal = (lastRaceWithResults !== -1) ? lastRaceWithResults.toString() : (selectedSeriesForDropdown.races[0]?.raceNumber?.toString() || null); }
            if (defaultRaceVal) resultsRace.value = defaultRaceVal;
            if (loadResultsAfterUpdate) { currentSeries = selectedSeriesForDropdown; currentRace = defaultRaceVal ? parseInt(defaultRaceVal) : null; loadRaceResults(); }
            else { if(defaultRaceVal) { currentSeries = selectedSeriesForDropdown; currentRace = parseInt(defaultRaceVal); } else { currentSeries = null; currentRace = null; } }
        }
        function populateRaceOptions(dropdown, seriesData, showDetails) {
            if (!dropdown || !seriesData || !seriesData.races) return; dropdown.innerHTML = '';
            const sortedRaces = [...seriesData.races].sort((a,b) => a.raceNumber - b.raceNumber);
            const maxRaceNumToShow = seriesData.isShortCourse
                ? (sortedRaces.length > 0 ? Math.max(...sortedRaces.map(r => r.raceNumber)) : 0)
                : seriesData.numberOfRaces;

            if (maxRaceNumToShow === 0 && sortedRaces.length === 0) {
                 dropdown.innerHTML = '<option value="">No races</option>';
                 dropdown.disabled = true;
                 return;
            }
             dropdown.disabled = false;
            for (let i = 1; i <= maxRaceNumToShow; i++) {
                const option = document.createElement('option'); option.value = i; let text = `Race ${i}`;
                const race = sortedRaces.find(r => r.raceNumber === i);
                if (showDetails && race) {
                    const hasResults = race.results && race.results.length > 0; let details = [];
                    if (hasResults) details.push("Saved");
                    if (race.date) { try { details.push(new Date(race.date + 'T00:00:00').toLocaleDateString('en-AU', {day:'numeric', month:'short'})); } catch (e) { console.error("Date format error", e)} }
                    if (details.length > 0) text += ` (${details.join(', ')})`; else if (!seriesData.isShortCourse || (race.entries && race.entries.length > 0)) text += ` (Not Saved)`;
                } else if (!race && !seriesData.isShortCourse) {
                     text += ` (Not Saved)`;
                } else if (!race && seriesData.isShortCourse) {
                     continue;
                }
                option.textContent = text; dropdown.appendChild(option);
            }
             if (dropdown.options.length === 0) {
                 dropdown.innerHTML = '<option value="">No races</option>';
                 dropdown.disabled = true;
             }
        }

        function updateRaceInfoAndEntries() {
             if (!currentSeries || currentSeries.isShortCourse) {
                 entries = []; renderEntriesTable(); editMode = false; editModeWarning?.classList.add('hidden');
                 return;
             }
             const selectedRaceNum = selectRace?.value;
             if (!selectedRaceNum) {
                 entries = []; renderEntriesTable(); editMode = false; editModeWarning?.classList.add('hidden'); clearEntryForm();
                 currentRace = null;
                 return;
             }
             currentRace = parseInt(selectedRaceNum);
             if (isNaN(currentRace)) {
                 entries = []; renderEntriesTable(); editMode = false; editModeWarning?.classList.add('hidden'); clearEntryForm();
                 currentRace = null;
                 return;
             }
             const race = currentSeries.races.find(r => r.raceNumber === currentRace);
             if (!race) {
                 entries = []; renderEntriesTable(); editMode = false; editModeWarning?.classList.add('hidden'); clearEntryForm(); return;
              }
             const hasSavedEntries = race.entries && race.entries.length > 0;
             const hasSavedResults = race.results && race.results.length > 0;
             if (hasSavedEntries || hasSavedResults) {
                 if (editMode && entries.length > 0) {
                     if (!confirm(`You have unsaved entries/changes. Load saved data for Race ${currentRace}? (Discards current changes)`)) {
                         if(editModeWarning) { editModeWarning.textContent = `WARNING: Viewing Race ${currentRace}, but unsaved changes exist from previous selection. Calculate & Save before proceeding.`; editModeWarning.classList.remove('hidden'); }
                         return;
                     }
                 }
                 if (hasSavedEntries) { entries = JSON.parse(JSON.stringify(race.entries)); }
                 else { entries = race.results.map(res => ({ sailNumber: res.sailNumber, boatClass: res.boatClass, skipper: res.skipper, yardstick: res.yardstick, status: res.status, elapsedTime: res.elapsedTime || '' })); }
                 renderEntriesTable(); clearEntryForm(); editMode = false; editModeWarning?.classList.add('hidden');
             } else {
                 if (editMode && entries.length > 0) {
                     if (!confirm(`You have unsaved entries/changes. Clear list for Race ${currentRace}? (Discards current changes)`)) {
                         if(editModeWarning) { editModeWarning.textContent = `WARNING: Viewing Race ${currentRace}, but unsaved changes exist from previous selection. Calculate & Save before proceeding.`; editModeWarning.classList.remove('hidden'); }
                         return;
                     }
                 }
                 entries = []; renderEntriesTable(); clearEntryForm(); editMode = false; editModeWarning?.classList.add('hidden');
             }
        }

        // Dropdown event listeners
        if(selectSeries) selectSeries.addEventListener('change', updateRaceEntryUI);
        if(selectRace) selectRace.addEventListener('change', () => {
             if (currentSeries && !currentSeries.isShortCourse) { updateRaceInfoAndEntries(); }
        });
        if(resultsSeries) resultsSeries.addEventListener('change', () => updateResultsRaceDropdown(true));
        if(resultsRace) resultsRace.addEventListener('change', () => { const raceNum = parseInt(resultsRace.value); if (!isNaN(raceNum)) { currentRace = raceNum; loadRaceResults(); } else { currentRace = null; results = []; renderRaceResults(); } });
        if(viewSeries) viewSeries.addEventListener('change', calculateSeriesResults);
        if(viewAllSeries) viewAllSeries.addEventListener('change', displayRaceViewer);


        // --- Load Race Results (Results Tab) ---
        function loadRaceResults() {
            currentSeries = series.find(s => s.id === parseInt(resultsSeries?.value)); currentRace = parseInt(resultsRace?.value);
            if (!currentSeries || isNaN(currentRace)) {
                 results = []; renderRaceResults(); disableDirectEditMode(); return;
            }
            const race = currentSeries.races.find(r => r.raceNumber === currentRace);
            if (!race || !race.results || race.results.length === 0) { results = []; renderRaceResults(); disableDirectEditMode(); return; }
            results = JSON.parse(JSON.stringify(race.results)); renderRaceResults(); disableDirectEditMode();
        }


        // --- Series Results Calculation ---
        function calculateSeriesResults() {
            const seriesId = viewSeries?.value;
            if (seriesResultsBody) seriesResultsBody.innerHTML = ''; if (seriesResultsHeader) seriesResultsHeader.innerHTML = '<tr><th>Loading...</th></tr>'; if (legendDiv) legendDiv.innerHTML = '<strong>Legend:</strong>';
            if (!seriesId) { if(seriesSummary) seriesSummary.innerHTML = '<p>Select a series.</p>'; if(seriesResultsHeader) seriesResultsHeader.innerHTML = ''; return; }
            const selectedSeries = series.find(s => s.id === parseInt(seriesId));
            if (!selectedSeries) { if(seriesSummary) seriesSummary.innerHTML = '<p>Error: Series not found.</p>'; if(seriesResultsHeader) seriesResultsHeader.innerHTML = ''; return; }

             const racesWithResults = selectedSeries.races.filter(r => r.results && r.results.length > 0);
             const completedRacesCount = racesWithResults.length;
             const totalRacesInSeries = selectedSeries.races.length;
             let numDiscardsToApply = 0;
             let discardRuleText = 'None';
             if (!selectedSeries.isShortCourse) {
                 const discardThreshold = selectedSeries.discardThreshold ?? 0;
                 if (discardThreshold > 0 && completedRacesCount > 0) {
                     numDiscardsToApply = Math.floor(completedRacesCount / discardThreshold);
                 }
                 discardRuleText = discardThreshold > 0 ? `1 per ${discardThreshold} completed races` : 'No discards';
             } else {
                 discardRuleText = 'N/A (Short Course)';
             }

            if (completedRacesCount === 0) {
                let summaryHTML = `<div class="race-info-panel"><h3>${selectedSeries.name} (${selectedSeries.isShortCourse ? 'Short Course' : 'Standard'})</h3>`;
                if (selectedSeries.isShortCourse) {
                     summaryHTML += `<p><strong>Races Saved:</strong> ${totalRacesInSeries}</p>`;
                } else {
                    summaryHTML += `<p><strong>Races Planned:</strong> ${selectedSeries.numberOfRaces}</p>`;
                }
                 summaryHTML += `<p><strong>Discard Rule:</strong> ${discardRuleText}</p><p style="color: orange; font-weight: bold;">No results saved yet.</p></div>`;
                 if(seriesSummary) seriesSummary.innerHTML = summaryHTML;
                 if(seriesResultsHeader) seriesResultsHeader.innerHTML = ''; if(seriesResultsBody) seriesResultsBody.innerHTML = '<tr><td colspan="6">No race results available.</td></tr>'; return;
             }
             let summaryHTML = `<div class="race-info-panel"><h3>${selectedSeries.name} (${selectedSeries.isShortCourse ? 'Short Course' : 'Standard'})</h3>`;
             if (selectedSeries.isShortCourse) {
                 summaryHTML += `<p><strong>Races Completed/Saved:</strong> ${completedRacesCount}</p>`;
             } else {
                 summaryHTML += `<p><strong>Races Planned:</strong> ${selectedSeries.numberOfRaces}</p>
                                <p><strong>Completed:</strong> ${completedRacesCount}</p>`;
             }
             summaryHTML += `<p><strong>Discard Rule:</strong> ${discardRuleText}</p>`;
             if (!selectedSeries.isShortCourse) {
                 summaryHTML += `<p><strong>Discards Applied Now:</strong> ${numDiscardsToApply}</p>`;
             }
              summaryHTML += `</div>`;
              if(seriesSummary) seriesSummary.innerHTML = summaryHTML;

             const raceNumbersInSeries = selectedSeries.races.map(r => r.raceNumber).sort((a, b) => a - b);
             if (raceNumbersInSeries.length === 0) {
                  if(seriesResultsHeader) seriesResultsHeader.innerHTML = ''; if(seriesResultsBody) seriesResultsBody.innerHTML = '<tr><td colspan="6">No races found.</td></tr>'; return;
             }
             let headerHTML = `<tr><th>Pos</th><th>Sail #</th><th>Skipper</th><th>Boat Class</th>`;
             raceNumbersInSeries.forEach(num => headerHTML += `<th>R${num}</th>`);
             headerHTML += `<th>Total</th><th>Net</th></tr>`;
             if(seriesResultsHeader) seriesResultsHeader.innerHTML = headerHTML;

             const competitors = new Map(); let allSailNumbers = new Set(); selectedSeries.races.forEach(r => { if(r.results) r.results.forEach(res => allSailNumbers.add(res.sailNumber)); });
             allSailNumbers.forEach(sailNo => {
                 if (!competitors.has(sailNo)) { let lastResult = null; for (let i = selectedSeries.races.length - 1; i >= 0; i--) { const r = selectedSeries.races[i]; if (r.results) { lastResult = r.results.find(res => res.sailNumber === sailNo); if (lastResult) break; } } competitors.set(sailNo, { sailNumber: sailNo, skipper: lastResult?.skipper || 'N/A', boatClass: lastResult?.boatClass || 'N/A', raceScores: new Map(), totalPoints: 0, netPoints: 0, position: 0 }); }
             });
             selectedSeries.races.forEach(race => { const raceNum = race.raceNumber; if (race.results && race.results.length > 0) { race.results.forEach(result => { const competitor = competitors.get(result.sailNumber); if(competitor) competitor.raceScores.set(raceNum, { points: result.points, status: result.status.toUpperCase(), position: result.position, discarded: false }); }); } });

             competitors.forEach(competitor => {
                  competitor.raceScores.forEach(score => { if (score) score.discarded = false; });
                  const dncRule = selectedSeries.dncScoringRule || 'raceEntries';
                  const totalSeriesCompetitors = competitors.size;
                  raceNumbersInSeries.forEach(raceNum => {
                      if (!competitor.raceScores.has(raceNum)) {
                          const correspondingRace = selectedSeries.races.find(r => r.raceNumber === raceNum);
                          if (correspondingRace && correspondingRace.results && correspondingRace.results.length > 0) {
                              let dncPoints;
                              if (dncRule === 'raceEntries') { const numEntriesInRace = correspondingRace.results.length; dncPoints = numEntriesInRace + 1; }
                              else { dncPoints = totalSeriesCompetitors + 1; }
                              competitor.raceScores.set(raceNum, { points: dncPoints, status: 'DNC', position: 'DNC', discarded: false });
                          } else {
                              competitor.raceScores.set(raceNum, { points: null, status: 'NR', position: 'NR', discarded: false });
                          }
                      } else {
                          const score = competitor.raceScores.get(raceNum);
                          if (score.status === 'OOD') {
                              score.points = calculateOODPointsSeriesContext(competitor.sailNumber, raceNum, selectedSeries, competitors);
                              competitor.raceScores.set(raceNum, score);
                          }
                      }
                  });
                  const validScores = Array.from(competitor.raceScores.values()).filter(score => score && score.points !== null && !isNaN(score.points));
                  competitor.totalPoints = validScores.reduce((sum, score) => sum + score.points, 0);
                  if (!selectedSeries.isShortCourse && validScores.length > 0 && numDiscardsToApply > 0) {
                      const scoresEligible = Array.from(competitor.raceScores.entries())
                          .filter(([rn, score]) => score && score.points !== null && !isNaN(score.points))
                          .map(([rn, score]) => ({ ...score, raceNumber: rn }))
                          .sort((a, b) => b.points - a.points);
                      for(let i = 0; i < Math.min(numDiscardsToApply, scoresEligible.length); i++){
                          const raceNumToDiscard = scoresEligible[i].raceNumber;
                          const scoreToDiscard = competitor.raceScores.get(raceNumToDiscard);
                          if (scoreToDiscard) scoreToDiscard.discarded = true;
                      }
                      competitor.netPoints = Array.from(competitor.raceScores.values())
                                                 .reduce((sum, score) => { if (score && score.points !== null && !isNaN(score.points) && !score.discarded) return sum + score.points; return sum; }, 0);
                  } else {
                      competitor.netPoints = competitor.totalPoints;
                      competitor.raceScores.forEach(score => { if(score) score.discarded = false; });
                  }
              });

             const competitorsArray = Array.from(competitors.values());
             competitorsArray.sort((a, b) => {
                 if (a.netPoints !== b.netPoints) return a.netPoints - b.netPoints;
                 let lastCommonRaceResult = 0;
                 const sortedRaceNumbersDesc = [...raceNumbersInSeries].sort((x, y) => y - x);
                 for (const raceNum of sortedRaceNumbersDesc) {
                      const scoreA = a.raceScores.get(raceNum);
                      const scoreB = b.raceScores.get(raceNum);
                      if (scoreA && scoreA.points != null && !isNaN(scoreA.points) && scoreB && scoreB.points != null && !isNaN(scoreB.points)) {
                          if (scoreA.points !== scoreB.points) { lastCommonRaceResult = scoreA.points - scoreB.points; break; }
                      } else if (scoreA && scoreA.points != null && !isNaN(scoreA.points)) { return -1;
                      } else if (scoreB && scoreB.points != null && !isNaN(scoreB.points)) { return 1; }
                 }
                 if (lastCommonRaceResult !== 0) return lastCommonRaceResult;
                 const scoresA = Array.from(a.raceScores.values()).filter(s => s && !s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                 const scoresB = Array.from(b.raceScores.values()).filter(s => s && !s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                 for (let i = 0; i < Math.min(scoresA.length, scoresB.length); i++) { if (scoresA[i] !== scoresB[i]) return scoresA[i] - scoresB[i]; }
                 if (scoresA.length !== scoresB.length) return scoresB.length - scoresA.length;
                 if (!selectedSeries.isShortCourse && numDiscardsToApply > 0) {
                    const discardedA = Array.from(a.raceScores.values()).filter(s => s && s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                    const discardedB = Array.from(b.raceScores.values()).filter(s => s && s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                     if (discardedA.length > 0 && discardedB.length > 0 && discardedA[0] !== discardedB[0]) return discardedA[0] - discardedB[0];
                 }
                 return a.sailNumber.localeCompare(b.sailNumber, undefined, { numeric: true });
             });

             let currentRank = 0; let currentPosition = 0;
             for (let i = 0; i < competitorsArray.length; i++) {
                 currentRank++;
                 if (i === 0 || checkTieBrokenSeries(competitorsArray[i], competitorsArray[i-1], raceNumbersInSeries, selectedSeries.isShortCourse, numDiscardsToApply)) {
                     currentPosition = currentRank;
                 }
                 competitorsArray[i].position = currentPosition;
             }
             function checkTieBrokenSeries(boatA, boatB, raceNums, isShort, discardsApplied) {
                 if (boatA.netPoints !== boatB.netPoints) return true;
                 const sortedRaceNumbersDesc = [...raceNums].sort((x, y) => y - x);
                 for (const raceNum of sortedRaceNumbersDesc) { const scoreA = boatA.raceScores.get(raceNum); const scoreB = boatB.raceScores.get(raceNum); if (scoreA?.points != null && !isNaN(scoreA.points) && scoreB?.points != null && !isNaN(scoreB.points)) { if(scoreA.points !== scoreB.points) return true; } else if (scoreA?.points != null && !isNaN(scoreA.points)) return true; else if (scoreB?.points != null && !isNaN(scoreB.points)) return true; }
                 const scoresA = Array.from(boatA.raceScores.values()).filter(s => s && !s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                 const scoresB = Array.from(boatB.raceScores.values()).filter(s => s && !s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                 for (let i = 0; i < Math.min(scoresA.length, scoresB.length); i++) { if (scoresA[i] !== scoresB[i]) return true; }
                 if (scoresA.length !== scoresB.length) return true;
                 if (!isShort && discardsApplied > 0) {
                    const discardedA = Array.from(boatA.raceScores.values()).filter(s => s && s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                    const discardedB = Array.from(boatB.raceScores.values()).filter(s => s && s.discarded && s.points !== null && !isNaN(s.points)).map(s => s.points).sort((x, y) => x - y);
                    if (discardedA.length > 0 && discardedB.length > 0 && discardedA[0] !== discardedB[0]) return true;
                 }
                 if (boatA.sailNumber.localeCompare(boatB.sailNumber, undefined, { numeric: true }) !== 0) return true;
                 return false;
              }

            if(seriesResultsBody) {
                 seriesResultsBody.innerHTML = ''; if (competitorsArray.length === 0) { const row = seriesResultsBody.insertRow(); row.insertCell().textContent = 'No competitors found with results in this series.'; row.cells[0].colSpan = raceNumbersInSeries.length + 6; return; }
                 competitorsArray.forEach(competitor => {
                     const row = seriesResultsBody.insertRow();
                     let rowHTML = `<td>${competitor.position}</td><td>${competitor.sailNumber}</td><td>${competitor.skipper}</td><td>${competitor.boatClass}</td>`;
                     raceNumbersInSeries.forEach(raceNum => {
                         const score = competitor.raceScores.get(raceNum);
                         if (!score || score.status === 'NR') { rowHTML += `<td class="nr-cell" title="No Race / Not Sailed">NR</td>`; }
                         else {
                             const points = (score.points !== null && !isNaN(score.points)) ? score.points : '-'; const status = score.status.toUpperCase(); let cellContent = points;
                             if (status !== 'FINISHED') cellContent = `${points}(${status})`;
                             const title = `title="${status} (Race Pos: ${score.position ?? status})"`;
                             rowHTML += `<td class="${score.discarded ? 'discarded' : ''}" ${title}>${cellContent}</td>`;
                         }
                     });
                     rowHTML += `<td>${competitor.totalPoints}</td><td><strong>${competitor.netPoints}</strong></td>`; row.innerHTML = rowHTML;
                 });
                 if (legendDiv) { legendDiv.innerHTML = `<strong>Legend:</strong> <span class="discarded-example">15</span> Discarded Score,&nbsp; <span class="nr-cell">NR</span> No Race/Not Sailed,&nbsp; <span>DNF</span> Did Not Finish,&nbsp; <span>DNS</span> Did Not Start,&nbsp; <span>OCS</span> On Course Side,&nbsp; <span>DSQ</span> Disqualified,&nbsp; <span>OOD</span> Race Officer Duty,&nbsp; <span>DNC</span> Did Not Compete (Race Sailed)`; }
             }
        }

        function calculateOODPointsSeriesContext(sailNo, oodRaceNumber, seriesData, competitorMap) {
             const competitor = competitorMap.get(sailNo); if (!competitor) return 0;
             let racePoints = []; let racesSailedCount = 0;
             competitor.raceScores.forEach((score, raceNum) => {
                 if (raceNum !== oodRaceNumber && score && score.points !== null && !isNaN(score.points) && score.status === 'FINISHED') {
                     racePoints.push(score.points);
                     racesSailedCount++;
                 }
             });
             if (racesSailedCount > 0) {
                 const avgPoints = racePoints.reduce((sum, pts) => sum + pts, 0) / racesSailedCount;
                 return Math.round(avgPoints * 10) / 10;
             }
             else {
                 const oodRaceData = seriesData.races.find(r => r.raceNumber === oodRaceNumber);
                 let fallbackPoints = 0;
                 let finisherPointsInOODRace = [];
                 if (oodRaceData && oodRaceData.results) {
                      oodRaceData.results.forEach(result => {
                          if (result.status === 'finished') {
                               const finisherCompetitor = competitorMap.get(result.sailNumber);
                               const finisherScore = finisherCompetitor?.raceScores.get(oodRaceNumber);
                               if (finisherScore && finisherScore.points != null && !isNaN(finisherScore.points)) {
                                   finisherPointsInOODRace.push(finisherScore.points);
                               }
                          }
                      });
                 }
                 if (finisherPointsInOODRace.length > 0) {
                     const avgFinisherPoints = finisherPointsInOODRace.reduce((sum, r) => sum + r, 0) / finisherPointsInOODRace.length;
                     fallbackPoints = Math.round(avgFinisherPoints * 10) / 10;
                 } else {
                     fallbackPoints = 0;
                 }
                 console.warn(`OOD Fallback used for ${sailNo} in Race ${oodRaceNumber}. Points: ${fallbackPoints}`);
                 return fallbackPoints;
             }
         }


        // --- Race Viewer Functions ---
        function displayRaceViewer() {
            const seriesId = viewAllSeries?.value;
            if (raceSelector) raceSelector.innerHTML = ''; if (individualRaceInfo) individualRaceInfo.innerHTML = ''; if (individualRaceBody) individualRaceBody.innerHTML = ''; if (raceSummaryView) raceSummaryView.innerHTML = '';
            if (!seriesId) { if(raceSummaryView) raceSummaryView.innerHTML = '<p>Select a series.</p>'; return; }
            const selectedSeries = series.find(s => s.id === parseInt(seriesId)); if (!selectedSeries) { if(raceSummaryView) raceSummaryView.innerHTML = '<p>Error: Series not found.</p>'; return; }
            const completedRaces = selectedSeries.races.filter(r => r.results && r.results.length > 0).length;
            const totalRacesSaved = selectedSeries.races.length;
            const seriesType = selectedSeries.isShortCourse ? 'Short Course' : 'Standard';
             let summaryHTML = `<div class="race-info-panel"><h3>${selectedSeries.name} (${seriesType})</h3>`;
             if (selectedSeries.isShortCourse) {
                 summaryHTML += `<p><strong>Races Completed/Saved:</strong> ${totalRacesSaved}</p>`;
             } else {
                 const discardThreshold = selectedSeries.discardThreshold ?? 0;
                 const discardRuleText = discardThreshold > 0 ? `1 discard per ${discardThreshold} completed races` : 'No discards';
                 summaryHTML += `<p><strong>Races Planned:</strong> ${selectedSeries.numberOfRaces}</p>
                                <p><strong>Completed:</strong> ${completedRaces}</p>
                                <p><strong>Discard Rule:</strong> ${discardRuleText}</p>`;
             }
             summaryHTML += `</div>`;
             if(raceSummaryView) raceSummaryView.innerHTML = summaryHTML;
             const raceNumbersToShow = selectedSeries.races.map(r => r.raceNumber).sort((a,b) => a - b);
             if (raceNumbersToShow.length === 0) {
                 if (raceSelector) raceSelector.innerHTML = '<p>No races saved in this series yet.</p>';
                 return;
             }
            let firstRaceWithResults = -1;
            if (raceSelector) {
                 raceNumbersToShow.forEach(raceNum => {
                    const raceBtn = document.createElement('button'); raceBtn.textContent = `Race ${raceNum}`; raceBtn.classList.add('race-button'); raceBtn.dataset.raceNumber = raceNum;
                    const race = selectedSeries.races.find(r => r.raceNumber === raceNum); const hasResults = race && race.results && race.results.length > 0;
                    if (hasResults) { raceBtn.classList.add('has-results'); if (firstRaceWithResults === -1) firstRaceWithResults = raceNum; if (race.date) { try { raceBtn.textContent += ` (${new Date(race.date + 'T00:00:00').toLocaleDateString('en-AU', {day:'numeric', month:'short'})})`; } catch (e) { console.error("Date format error", e)} } }
                    raceBtn.addEventListener('click', (e) => { document.querySelectorAll('.race-button.active').forEach(btn => btn.classList.remove('active')); e.target.classList.add('active'); displayRaceResultsView(selectedSeries, raceNum); });
                    raceSelector.appendChild(raceBtn);
                 });
            }
            let lastRaceWithResults = -1;
             for(let i = selectedSeries.races.length - 1; i >= 0; i--){
                 const race = selectedSeries.races[i];
                 if(race && race.results && race.results.length > 0){
                     lastRaceWithResults = race.raceNumber; break;
                 }
             }
             const targetRaceNum = lastRaceWithResults !== -1 ? lastRaceWithResults : (raceNumbersToShow.length > 0 ? raceNumbersToShow[0] : null);
            if (targetRaceNum) { const targetButton = raceSelector?.querySelector(`.race-button[data-race-number="${targetRaceNum}"]`); if (targetButton) { targetButton.classList.add('active'); displayRaceResultsView(selectedSeries, targetRaceNum); } }
            else { if(individualRaceInfo) individualRaceInfo.innerHTML = '<p>Select a race button above.</p>'; }
        }

        function displayRaceResultsView(selectedSeriesData, raceNumber) {
             if (!individualRaceBody || !individualRaceInfo || !selectedSeriesData) return; individualRaceBody.innerHTML = ''; individualRaceInfo.innerHTML = '';
             const race = selectedSeriesData.races.find(r => r.raceNumber === parseInt(raceNumber));
             if (!race || !race.results || race.results.length === 0) { individualRaceInfo.innerHTML = `<div class="race-info-panel"><h3>Race ${raceNumber} Results</h3><p>No results saved for this race.</p></div>`; const row = individualRaceBody.insertRow(); const cell = row.insertCell(); cell.colSpan = 9; cell.textContent = 'No results saved for this race.'; cell.style.textAlign = 'center'; cell.style.fontStyle = 'italic'; cell.style.color = '#666'; return; }
             const date = race.date ? new Date(race.date + 'T00:00:00').toLocaleDateString() : 'Not set';
             individualRaceInfo.innerHTML = `<div class="race-info-panel"><h3>Race ${race.raceNumber} Results</h3><p><strong>Date:</strong> ${date}</p><p><strong>Entries:</strong> ${race.results.length}</p></div>`;
             const sortedResults = [...race.results].sort((a, b) => { const posA = (typeof a.position === 'number') ? a.position : Infinity; const posB = (typeof b.position === 'number') ? b.position : Infinity; if(posA !== posB) return posA - posB; const pointsA = (a.points != null) ? a.points : Infinity; const pointsB = (b.points != null) ? b.points : Infinity; if (pointsA !== pointsB) return pointsA - pointsB; return a.sailNumber.localeCompare(b.sailNumber); });
             sortedResults.forEach(result => {
                 const row = individualRaceBody.insertRow();
                 row.innerHTML = `
                     <td>${result.position ?? '-'}</td><td>${result.sailNumber}</td><td>${result.boatClass}</td><td>${result.skipper}</td>
                     <td>${result.yardstick}</td><td>${result.status.toUpperCase()}</td><td>${result.elapsedTime || '-'}</td><td>${result.correctedTime || '-'}</td>
                     <td>${result.points ?? '-'}</td>`;
             });
         }

        // --- Google Sheets Data Persistence ---
        async function saveDataToGoogleSheet() {
            if (!WEB_APP_URL) {
                console.error("WEB_APP_URL is not defined. Cannot save to Google Sheet.");
                alert("Configuration error: Web App URL not set. Data not saved to cloud.");
                return;
            }
            if (loadingOverlay) loadingOverlay.classList.remove('hidden');
            console.log("Saving to Google Sheet...");

            const dataToSave = {
                seriesData: series,
                boatListData: boatList
            };

            try {
                const response = await fetch(WEB_APP_URL, {
                    method: 'POST',
                    mode: 'cors',
                    cache: 'no-cache',
                    headers: { 'Content-Type': 'text/plain' }, // Send as plain text for GAS
                    body: JSON.stringify(dataToSave),
                    redirect: 'follow'
                });

                const resultText = await response.text();
                let result;
                try {
                    result = JSON.parse(resultText);
                } catch (e) {
                    console.error("Failed to parse response from Google Sheet save:", resultText);
                    throw new Error("Invalid response from server: " + resultText.substring(0,100) + "...");
                }

                if (result.status === "success") {
                    console.log("Data successfully saved to Google Sheet:", result.message);
                } else {
                    console.error("Error saving to Google Sheet:", result.message);
                    alert("Error saving to Google Sheet: " + result.message + "\nPlease check the script logs if you are the owner.");
                }
            } catch (error) {
                console.error("Fetch error while saving to Google Sheet:", error);
                alert("Failed to connect to Google Sheet to save data. Error: " + error.message);
            } finally {
                if (loadingOverlay) loadingOverlay.classList.add('hidden');
            }
        }

        async function loadDataFromGoogleSheet() {
            if (!WEB_APP_URL) {
                console.error("WEB_APP_URL is not defined. Cannot load from Google Sheet.");
                series = []; boatList = []; return;
            }
             if (loadingOverlay) { loadingOverlay.textContent = "Loading from Cloud..."; loadingOverlay.classList.remove('hidden'); }
            console.log("Loading from Google Sheet...");

            try {
                const response = await fetch(WEB_APP_URL, {
                    method: 'GET', mode: 'cors', cache: 'no-cache', redirect: 'follow'
                });
                const resultText = await response.text();
                let data;
                try {
                    data = JSON.parse(resultText);
                } catch (e) {
                    console.error("Failed to parse response from Google Sheet load:", resultText);
                    throw new Error("Invalid response from server: " + resultText.substring(0,100) + "...");
                }

                if (data.status === "success") {
                    console.log("Data successfully loaded from Google Sheet.");
                    // Series Data Validation & Migration
                    if (data.seriesData && Array.isArray(data.seriesData)) {
                        series = data.seriesData.map((s, index) => {
                            if (!s || typeof s !== 'object') { console.warn(`GS Load: Invalid series data at index ${index}, skipping.`); return null; }
                            s.id = s.id || (Date.now() + index);
                            s.name = s.name || `Series ${s.id}`;
                            s.races = (Array.isArray(s.races) ? s.races : []).map((r, r_idx) => {
                                if (!r || typeof r !== 'object') return { raceNumber: r_idx + 1, date: null, entries: [], results: [] };
                                r.raceNumber = typeof r.raceNumber === 'number' ? r.raceNumber : r_idx + 1;
                                r.entries = (Array.isArray(r.entries) ? r.entries : []).map(entry => ({...entry, elapsedTime: entry.elapsedTime || ''}));
                                r.results = (Array.isArray(r.results) ? r.results : []).map(result => ({...result, elapsedTime: result.elapsedTime || ''}));
                                r.date = r.date || null;
                                return r;
                            });
                            s.isShortCourse = typeof s.isShortCourse === 'boolean' ? s.isShortCourse : false;
                            s.numberOfRaces = typeof s.numberOfRaces === 'number' ? s.numberOfRaces : (s.isShortCourse ? s.races.length : 0);
                            s.discardThreshold = typeof s.discardThreshold === 'number' ? s.discardThreshold : 0;
                            s.dncScoringRule = ['raceEntries', 'seriesCompetitors'].includes(s.dncScoringRule) ? s.dncScoringRule : 'raceEntries';

                            if (!s.isShortCourse) {
                                const expectedNumRaces = s.numberOfRaces || 0;
                                if (s.races.length !== expectedNumRaces) {
                                   console.warn(`GS Load: Fixing race structure for standard series "${s.name}". Expected ${expectedNumRaces}, found ${s.races.length}.`);
                                   let existingRacesData = new Map();
                                   s.races.forEach(r_item => { if (r_item && typeof r_item.raceNumber === 'number') existingRacesData.set(r_item.raceNumber, r_item); });
                                   let reconciledRaces = [];
                                   for (let i_race = 1; i_race <= expectedNumRaces; i_race++) {
                                       const existing = existingRacesData.get(i_race);
                                       reconciledRaces.push({
                                           raceNumber: i_race,
                                           date: existing?.date || null,
                                           entries: (Array.isArray(existing?.entries) ? existing.entries : []).map(entry => ({...entry, elapsedTime: entry.elapsedTime || ''})),
                                           results: (Array.isArray(existing?.results) ? existing.results : []).map(result => ({...result, elapsedTime: result.elapsedTime || ''}))
                                       });
                                   }
                                   s.races = reconciledRaces;
                                }
                            }
                            s.races.sort((a, b) => (a.raceNumber || 0) - (b.raceNumber || 0));
                            return s;
                        }).filter(s => s !== null);
                    } else {
                        series = [];
                        if(data.message && data.status !== "success") console.warn("Series data not found or error in response:", data.message);
                        else if (!data.seriesData) console.warn("Series data missing from successful GS response.");
                    }

                    // Boat List Data Validation & Migration
                    if (data.boatListData && Array.isArray(data.boatListData)) {
                        const existingIds = new Set();
                        boatList = data.boatListData.map((b, index) => {
                            if (!b || typeof b !== 'object') return null;
                            let id = b.id || (Date.now() + index + Math.random());
                            if(existingIds.has(id)) id = Date.now() + index + Math.random() + "_dup_gs";
                            existingIds.add(id);
                            const sailNumber = (typeof b.sailNumber === 'string' || typeof b.sailNumber === 'number') ? String(b.sailNumber).toUpperCase().trim() : `Imported_${index}`;
                            const boatClass = typeof b.boatClass === 'string' ? b.boatClass.trim() : 'Unknown';
                            const skipper = typeof b.skipper === 'string' ? b.skipper.trim() : 'Unknown';
                            const yardstick = typeof b.yardstick === 'number' && !isNaN(b.yardstick) ? b.yardstick : 0;
                            if (!sailNumber || !boatClass || !skipper || yardstick <= 0) {
                                 console.warn(`GS Load: Imported boat missing data, assigning defaults/skipping: ID ${id}`); return null;
                            }
                            return { id, sailNumber, boatClass, skipper, yardstick };
                        }).filter(b => b !== null);
                    } else {
                        boatList = [];
                        if(data.message && data.status !== "success") console.warn("BoatList data not found or error in response:", data.message);
                        else if (!data.boatListData) console.warn("BoatList data missing from successful GS response.");
                    }
                } else {
                    console.error("Error loading from Google Sheet:", data.message || "Unknown error from script.");
                    alert("Error loading data from Google Sheet: " + (data.message || "Unknown error") + "\nApp will start with empty data.");
                    series = []; boatList = [];
                }
            } catch (error) {
                console.error("Fetch error while loading from Google Sheet:", error);
                alert("Failed to connect to Google Sheet to load data. Error: " + error.message + "\nApp will start with empty data.");
                series = []; boatList = [];
            } finally {
                if (loadingOverlay) loadingOverlay.classList.add('hidden');
            }
        }


        // --- Export Data Function (Local JSON Backup) ---
        function exportAllData() {
            if (series.length === 0 && boatList.length === 0) { alert("No data (series or boats) available to export."); return; }
            try {
                const exportData = {
                    version: "LysterfieldResultsApp_vGS_1.0", // Indicate this is from GS integrated version
                    exportDate: new Date().toISOString(),
                    seriesData: series,
                    boatListData: boatList
                };
                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const dateStr = new Date().toISOString().split('T')[0];
                a.download = `lysterfield_gs_backup_${dateStr}.json`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                alert("Data exported to local JSON file successfully!");
            } catch (error) { console.error("Error during data export:", error); alert("An error occurred while exporting data."); }
        }
        function exportBoatList() { // For exporting only the boat list
            if (boatList.length === 0) { alert("No boats in the list to export."); return; }
            try {
                const jsonString = JSON.stringify(boatList, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const dateStr = new Date().toISOString().split('T')[0];
                a.download = `lysterfield_boat_list_${dateStr}.json`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                alert("Boat list exported to local JSON file successfully!");
            } catch (error) { console.error("Error during boat list export:", error); alert("An error occurred while exporting the boat list."); }
        }


        // --- Import Data Function (From Local JSON Backup) ---
        async function importData(event) { // Made async
            const file = event.target.files[0]; if (!file) return;
            if (!confirm("IMPORTING DATA WILL REPLACE ALL CURRENT IN-APP DATA AND THEN SAVE IT TO GOOGLE SHEETS. Are you absolutely sure?")) { importFileInput.value = null; return; }
            const reader = new FileReader();
            reader.onload = async function(e) { // Made async
                try {
                    const fileContent = e.target.result; const parsedData = JSON.parse(fileContent);
                    if (!parsedData || typeof parsedData !== 'object' || !Array.isArray(parsedData.seriesData) || !Array.isArray(parsedData.boatListData)) { throw new Error("Invalid file format. Expected object with 'seriesData' and 'boatListData' arrays."); }

                    // Apply same validation as loadFromGoogleSheet (or your original localStorage load)
                    // Series Data
                    if (parsedData.seriesData && Array.isArray(parsedData.seriesData)) {
                        series = parsedData.seriesData.map((s, index) => { /* ... (same validation as in loadDataFromGoogleSheet) ... */
                            if (!s || typeof s !== 'object') { console.warn(`JSON Import: Invalid series data at index ${index}, skipping.`); return null; }
                            s.id = s.id || (Date.now() + index);
                            s.name = s.name || `Series ${s.id}`;
                            s.races = (Array.isArray(s.races) ? s.races : []).map((r, r_idx) => {
                                if (!r || typeof r !== 'object') return { raceNumber: r_idx + 1, date: null, entries: [], results: [] };
                                r.raceNumber = typeof r.raceNumber === 'number' ? r.raceNumber : r_idx + 1;
                                r.entries = (Array.isArray(r.entries) ? r.entries : []).map(entry => ({...entry, elapsedTime: entry.elapsedTime || ''}));
                                r.results = (Array.isArray(r.results) ? r.results : []).map(result => ({...result, elapsedTime: result.elapsedTime || ''}));
                                r.date = r.date || null;
                                return r;
                            });
                            s.isShortCourse = typeof s.isShortCourse === 'boolean' ? s.isShortCourse : false;
                            s.numberOfRaces = typeof s.numberOfRaces === 'number' ? s.numberOfRaces : (s.isShortCourse ? s.races.length : 0);
                            s.discardThreshold = typeof s.discardThreshold === 'number' ? s.discardThreshold : 0;
                            s.dncScoringRule = ['raceEntries', 'seriesCompetitors'].includes(s.dncScoringRule) ? s.dncScoringRule : 'raceEntries';
                             if (!s.isShortCourse) {
                                const expectedNumRaces = s.numberOfRaces || 0;
                                if (s.races.length !== expectedNumRaces) {
                                   console.warn(`JSON Import: Fixing race structure for standard series "${s.name}". Expected ${expectedNumRaces}, found ${s.races.length}.`);
                                   let existingRacesData = new Map();
                                   s.races.forEach(r_item => { if (r_item && typeof r_item.raceNumber ==='number') existingRacesData.set(r_item.raceNumber, r_item); });
                                   let reconciledRaces = [];
                                   for (let i_race = 1; i_race <= expectedNumRaces; i_race++) {
                                       const existing = existingRacesData.get(i_race);
                                       reconciledRaces.push({
                                           raceNumber: i_race,
                                           date: existing?.date || null,
                                           entries: (Array.isArray(existing?.entries) ? existing.entries : []).map(entry => ({...entry, elapsedTime: entry.elapsedTime || ''})),
                                           results: (Array.isArray(existing?.results) ? existing.results : []).map(result => ({...result, elapsedTime: result.elapsedTime || ''}))
                                       });
                                   }
                                   s.races = reconciledRaces;
                                }
                            }
                            s.races.sort((a, b) => (a.raceNumber || 0) - (b.raceNumber || 0));
                            return s;
                        }).filter(s => s !== null);
                    } else { series = []; }

                    // Boat List Data
                    if (parsedData.boatListData && Array.isArray(parsedData.boatListData)) {
                        const existingIds = new Set();
                        boatList = parsedData.boatListData.map((b, index) => { /* ... (same validation as in loadDataFromGoogleSheet) ... */
                            if (!b || typeof b !== 'object') return null;
                            let id = b.id || (Date.now() + index + Math.random());
                            if(existingIds.has(id)) id = Date.now() + index + Math.random() + "_dup_json";
                            existingIds.add(id);
                            const sailNumber = (typeof b.sailNumber === 'string' || typeof b.sailNumber === 'number') ? String(b.sailNumber).toUpperCase().trim() : `Imported_${index}`;
                            const boatClass = typeof b.boatClass === 'string' ? b.boatClass.trim() : 'Unknown';
                            const skipper = typeof b.skipper === 'string' ? b.skipper.trim() : 'Unknown';
                            const yardstick = typeof b.yardstick === 'number' && !isNaN(b.yardstick) ? b.yardstick : 0;
                            if (!sailNumber || !boatClass || !skipper || yardstick <= 0) { console.warn(`JSON Import: Imported boat missing data, skipping: ID ${id}`); return null; }
                            return { id, sailNumber, boatClass, skipper, yardstick };
                        }).filter(b => b !== null);
                    } else { boatList = []; }

                    await saveDataToGoogleSheet(); // Sync imported data to Google Sheet

                    refreshSeriesList(); refreshSeriesDropdowns(); renderBoatListTable(); populateSavedBoatDropdown();
                    entries = []; results = []; currentSeries = null; currentRace = null; shortCourseSessionRaces = [];
                    if(raceTab?.classList.contains('active-tab')) updateRaceEntryUI();
                    if(resultsTab?.classList.contains('active-tab')) renderRaceResults();
                    if(seriesResultsTab?.classList.contains('active-tab')) calculateSeriesResults();
                    if(raceViewTab?.classList.contains('active-tab')) displayRaceViewer();
                    setActiveTab(seriesTab);
                    alert("Data imported from JSON and saved to Google Sheets successfully!");
                } catch (error) { console.error("Error during data import from JSON:", error); alert("Error importing data: " + error.message + ". Data not changed."); }
                finally { importFileInput.value = null; }
            };
            reader.onerror = function() { alert("Error reading the selected file."); importFileInput.value = null; };
            reader.readAsText(file);
        }

        async function importBoatList(event) { // Made async
            const file = event.target.files[0]; if (!file) return;
            if (!confirm("IMPORTING BOAT LIST WILL REPLACE YOUR CURRENT SAVED BOAT LIST (in app & then Google Sheets). Series data will NOT be affected. Are you sure?")) { importBoatListFileInput.value = null; return; }
            const reader = new FileReader();
            reader.onload = async function(e) { // Made async
                try {
                    const fileContent = e.target.result; let parsedData = JSON.parse(fileContent);
                    let importedList;
                    if (Array.isArray(parsedData)) {
                        importedList = parsedData;
                    } else if (parsedData && typeof parsedData === 'object' && Array.isArray(parsedData.boatListData)) {
                        importedList = parsedData.boatListData;
                    } else {
                        throw new Error("Invalid file format. Expected an array of boats or an object with a 'boatListData' array.");
                    }
                     const existingIds = new Set();
                     boatList = importedList.map((b, index) => { /* ... (same validation as in loadDataFromGoogleSheet) ... */
                         if (!b || typeof b !== 'object') return null;
                         let id = b.id || (Date.now() + index + Math.random());
                         if(existingIds.has(id)) id = Date.now() + index + Math.random() + "_dup_json_bl";
                         existingIds.add(id);
                         const sailNumber = (typeof b.sailNumber === 'string' || typeof b.sailNumber === 'number') ? String(b.sailNumber).toUpperCase().trim() : `Imported_${index}`;
                         const boatClass = typeof b.boatClass === 'string' ? b.boatClass.trim() : 'Unknown';
                         const skipper = typeof b.skipper === 'string' ? b.skipper.trim() : 'Unknown';
                         const yardstick = typeof b.yardstick === 'number' && !isNaN(b.yardstick) ? b.yardstick : 0;
                         if (!sailNumber || !boatClass || !skipper || yardstick <= 0) { console.warn(`JSON Import (Boat List): Imported boat missing data, skipping: ID ${id}`); return null; }
                         return { id, sailNumber, boatClass, skipper, yardstick };
                     }).filter(b => b !== null);

                    await saveDataToGoogleSheet(); // Sync imported boat list to Google Sheet

                    renderBoatListTable(); populateSavedBoatDropdown();
                    alert("Boat list imported from JSON and saved to Google Sheets successfully!");
                } catch (error) { console.error("Error during boat list import from JSON:", error); alert("Error importing boat list: " + error.message + ". List not changed."); }
                finally { importBoatListFileInput.value = null; }
            };
            reader.onerror = function() { alert("Error reading the selected file."); importBoatListFileInput.value = null; };
            reader.readAsText(file);
        }

        // --- Initialization ---
        async function initApp() { // Made async
            console.log("Initializing Sailing App (Google Sheets Mode)...");
            initYardsticks();

            await loadDataFromGoogleSheet(); // Load data from Google Sheet first

            refreshSeriesList();
            refreshSeriesDropdowns();
            renderBoatListTable();
            setActiveTab(seriesTab);

            if (exportAllDataBtn) exportAllDataBtn.addEventListener('click', exportAllData);
            if (importDataBtn && importFileInput) { importDataBtn.addEventListener('click', () => importFileInput.click()); importFileInput.addEventListener('change', importData); }
            if (exportBoatListBtn) exportBoatListBtn.addEventListener('click', exportBoatList);
            if (importBoatListBtn && importBoatListFileInput) { importBoatListBtn.addEventListener('click', () => importBoatListFileInput.click()); importBoatListFileInput.addEventListener('change', importBoatList); }

            console.log("App Initialized. Series loaded:", series.length, "Boats loaded:", boatList.length);
        }

        // Make functions globally accessible for onclick handlers/inline events
         window.editEntry = editEntry;
         window.removeEntry = removeEntry;
         window.editSeries = editSeries;
         window.deleteSeries = deleteSeries;
         window.showEditResultDialog = showEditResultDialog;
         window.editBoatInList = editBoatInList;
         window.deleteBoatFromList = deleteBoatFromList;
         window.editShortCourseEntry = editShortCourseEntry;
         window.removeShortCourseEntry = removeShortCourseEntry;
         window.updateShortCourseEntry = updateShortCourseEntry;

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', initApp);

    </script>
</body>
</html>